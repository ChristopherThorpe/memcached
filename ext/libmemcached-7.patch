diff -ur a/libmemcached-0.32/docs/libmemcached.pod b/libmemcached-0.32/docs/libmemcached.pod
--- a/libmemcached-0.32/docs/libmemcached.pod	2009-06-14 08:18:14.000000000 -0700
+++ b/libmemcached-0.32/docs/libmemcached.pod	2011-03-02 21:44:44.000000000 -0800
@@ -35,7 +35,7 @@
 Nearly all functions return a C<memcached_return> value.
 This value can be translated to a printable string with memcached_strerror(3).
 
-Partitioning based on keys is supported in the library. Using the key partioning 
+Partitioning based on keys is supported in the library. Using the key partioning
 functions it is possible to group sets of object onto servers.
 
 C<memcached_st> structures are thread-safe, but each thread must
@@ -44,13 +44,13 @@
 used in this library.
 
 If you are working with GNU autotools you will want to add the following to
-your configure.ac to properly include libmemcached in your application. 
+your configure.ac to properly include libmemcached in your application.
 
 PKG_CHECK_MODULES(DEPS, libmemcached >= 0.8.0)
 AC_SUBST(DEPS_CFLAGS)
 AC_SUBST(DEPS_LIBS)
 
-Some features of the library must be enabled through memcached_behavior_set(). 
+Some features of the library must be enabled through memcached_behavior_set().
 
 Hope you enjoy it!
 
@@ -73,10 +73,6 @@
 
 Default size of key (which includes the null pointer).
 
-=item MEMCACHED_STRIDE
-
-This is the "stride" used in the consistent hash used between replicas.
-
 =item MEMCACHED_MAX_HOST_LENGTH
 
 Maximum allowed size of the hostname.
@@ -87,15 +83,15 @@
 
 =item MEMCACHED_MAJOR_VERSION
 
-Major version value. Such as 1.23.4, would be 1 
+Major version value. Such as 1.23.4, would be 1
 
 =item MEMCACHED_MINOR_VERSION
 
-Major version value. Such as 1.23.4, would be 23 
+Major version value. Such as 1.23.4, would be 23
 
 =item MEMCACHED_MICRO_VERSION
 
-Major version value. Such as 1.23.4, would be 4 
+Major version value. Such as 1.23.4, would be 4
 
 
 =back
diff -ur a/libmemcached-0.32/docs/memcached_behavior.pod b/libmemcached-0.32/docs/memcached_behavior.pod
--- a/libmemcached-0.32/docs/memcached_behavior.pod	2009-06-27 10:46:16.000000000 -0700
+++ b/libmemcached-0.32/docs/memcached_behavior.pod	2011-03-02 21:45:30.000000000 -0800
@@ -32,7 +32,7 @@
 
 memcached_behavior_set() changes the value of a particular option of the
 client. It takes both a flag (listed below) and a value. For simple on or
-off options you just need to pass in a value of 1. Calls to 
+off options you just need to pass in a value of 1. Calls to
 memcached_behavior_set() will flush and reset all connections.
 
 =over 4
@@ -40,7 +40,7 @@
 =item MEMCACHED_BEHAVIOR_USE_UDP
 
 Causes libmemcached(3) to use the UDP transport when communicating
-with a memcached server. Not all I/O operations are supported 
+with a memcached server. Not all I/O operations are supported
 when this behavior is enababled. The following operations will return
 C<MEMCACHED_NOT_SUPPORTED> when executed with the MEMCACHED_BEHAVIOR_USE_UDP
 enabled: memcached_version(), memcached_stat(), memcached_get(),
@@ -50,7 +50,7 @@
 All other operations are supported but are executed in a 'fire-and-forget'
 mode, in which once the client has executed the operation, no attempt
 will be made to ensure the operation has been received and acted on by the
-server. 
+server.
 
 libmemcached(3) does not allow TCP and UDP servers to be shared within
 the same libmemached(3) client 'instance'. An attempt to add a TCP server
@@ -82,19 +82,19 @@
 =item MEMCACHED_BEHAVIOR_HASH
 
 Makes the default hashing algorithm for keys use MD5. The value can be set
-to either MEMCACHED_HASH_DEFAULT, MEMCACHED_HASH_MD5, MEMCACHED_HASH_CRC, MEMCACHED_HASH_FNV1_64, MEMCACHED_HASH_FNV1A_64, MEMCACHED_HASH_FNV1_32, MEMCACHED_HASH_FNV1A_32, MEMCACHED_HASH_JENKINS, MEMCACHED_HASH_HSIEH, and MEMCACHED_HASH_MURMUR. 
+to either MEMCACHED_HASH_DEFAULT, MEMCACHED_HASH_MD5, MEMCACHED_HASH_CRC, MEMCACHED_HASH_FNV1_64, MEMCACHED_HASH_FNV1A_64, MEMCACHED_HASH_FNV1_32, MEMCACHED_HASH_FNV1A_32, MEMCACHED_HASH_JENKINS, MEMCACHED_HASH_HSIEH, and MEMCACHED_HASH_MURMUR.
 Each hash has it's advantages and it's weaknesses. If you dont know or dont care, just go with the default.
-Support for MEMCACHED_HASH_HSIEH is a compile time option that is disabled by default. To enable support for this hashing algorithm, configure and build libmemcached with the --enable-hash_hsieh. 
+Support for MEMCACHED_HASH_HSIEH is a compile time option that is disabled by default. To enable support for this hashing algorithm, configure and build libmemcached with the --enable-hash_hsieh.
 
 =item MEMCACHED_BEHAVIOR_DISTRIBUTION
 
 Using this you can enable different means of distributing values to servers.
 The default method is MEMCACHED_DISTRIBUTION_MODULA. You can enable
-consistent hashing by setting MEMCACHED_DISTRIBUTION_CONSISTENT. 
-Consistent hashing delivers better distribution and allows servers to be 
+consistent hashing by setting MEMCACHED_DISTRIBUTION_CONSISTENT.
+Consistent hashing delivers better distribution and allows servers to be
 added to the cluster with minimal cache losses. Currently
 MEMCACHED_DISTRIBUTION_CONSISTENT is an alias for the value
-MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA.  
+MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA.
 
 =item MEMCACHED_BEHAVIOR_CACHE_LOOKUPS
 
@@ -117,7 +117,7 @@
 =item MEMCACHED_BEHAVIOR_KETAMA_HASH
 
 Sets the hashing algorithm for host mapping on continuum. The value can be set
-to either MEMCACHED_HASH_DEFAULT, MEMCACHED_HASH_MD5, MEMCACHED_HASH_CRC, MEMCACHED_HASH_FNV1_64, MEMCACHED_HASH_FNV1A_64, MEMCACHED_HASH_FNV1_32, and MEMCACHED_HASH_FNV1A_32. 
+to either MEMCACHED_HASH_DEFAULT, MEMCACHED_HASH_MD5, MEMCACHED_HASH_CRC, MEMCACHED_HASH_FNV1_64, MEMCACHED_HASH_FNV1A_64, MEMCACHED_HASH_FNV1_32, and MEMCACHED_HASH_FNV1A_32.
 
 =item MEMCACHED_BEHAVIOR_POLL_TIMEOUT
 
@@ -136,16 +136,16 @@
 Enabling buffered IO causes commands to "buffer" instead of being sent. Any
 action that gets data causes this buffer to be be sent to the remote
 connection. Quiting the connection or closing down the connection will also
-cause the buffered data to be pushed to the remote connection. 
+cause the buffered data to be pushed to the remote connection.
 
 =item MEMCACHED_BEHAVIOR_VERIFY_KEY
 
-Enabling this will cause libmemcached(3) to test all keys to verify that they 
+Enabling this will cause libmemcached(3) to test all keys to verify that they
 are valid keys.
 
 =item MEMCACHED_BEHAVIOR_SORT_HOSTS
 
-Enabling this will cause hosts that are added to be placed in the host list in 
+Enabling this will cause hosts that are added to be placed in the host list in
 sorted order. This will defeat consisten hashing.
 
 =item MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT
@@ -165,7 +165,7 @@
 
 =item MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK
 
-Set this value to tune the number of messages that may be sent before 
+Set this value to tune the number of messages that may be sent before
 libmemcached should start to automatically drain the input queue. Setting
 this value to high, may cause libmemcached to deadlock (trying to send data,
 but the send will block because the input buffer in the kernel is full).
@@ -175,7 +175,7 @@
 Set this value to tune the number of bytes that may be sent before
 libmemcached should start to automatically drain the input queue (need
 at least 10 IO requests sent without reading the input buffer). Setting
-this value to high, may cause libmemcached to deadlock (trying to send 
+this value to high, may cause libmemcached to deadlock (trying to send
 data, but the send will block because the input buffer in the kernel is full).
 
 =item MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH
@@ -192,15 +192,7 @@
 =item MEMCACHED_BEHAVIOR_NOREPLY
 
 Set this value to specify that you really don't care about the result
-from your storage commands (set, add, replace, append, prepend). 
-
-=item MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS
-
-If you just want "a poor mans HA", you may specify the numbers of
-replicas libmemcached should store of each item (on different servers).
-This replication does not dedicate certain memcached servers to store the
-replicas in, but instead it will store the replicas together with all of the
-other objects (on the 'n' next servers specified in your server list).
+from your storage commands (set, add, replace, append, prepend).
 
 =back
 
@@ -213,7 +205,7 @@
 =head1 NOTES
 
 memcached_behavior_set() in version .17 was changed from taking a pointer
-to data value, to taking a uin64_t. 
+to data value, to taking a uin64_t.
 
 =head1 HOME
 
diff -ur a/libmemcached-0.32/libmemcached/memcached.c b/libmemcached-0.32/libmemcached/memcached.c
--- a/libmemcached-0.32/libmemcached/memcached.c	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached.c	2011-03-02 21:44:27.000000000 -0800
@@ -108,7 +108,6 @@
   new_clone->io_msg_watermark= source->io_msg_watermark;
   new_clone->io_bytes_watermark= source->io_bytes_watermark;
   new_clone->io_key_prefetch= source->io_key_prefetch;
-  new_clone->number_of_replicas= source->number_of_replicas;
 
   if (source->hosts)
     rc= memcached_server_push(new_clone, source->hosts);
diff -ur a/libmemcached-0.32/libmemcached/memcached.h b/libmemcached-0.32/libmemcached/memcached.h
--- a/libmemcached-0.32/libmemcached/memcached.h	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached.h	2011-03-02 21:44:17.000000000 -0800
@@ -112,7 +112,6 @@
   memcached_trigger_key get_key_failure;
   memcached_trigger_delete_key delete_trigger;
   char prefix_key[MEMCACHED_PREFIX_KEY_MAX_SIZE];
-  uint32_t number_of_replicas;
   uint32_t number_of_live_hosts;
   uint32_t *live_host_indices;
   uint32_t live_host_indices_size;
diff -ur a/libmemcached-0.32/libmemcached/memcached_behavior.c b/libmemcached-0.32/libmemcached/memcached_behavior.c
--- a/libmemcached-0.32/libmemcached/memcached_behavior.c	2009-09-15 13:32:40.000000000 -0700
+++ b/libmemcached-0.32/libmemcached/memcached_behavior.c	2011-03-02 21:44:58.000000000 -0800
@@ -1,10 +1,10 @@
-#include "common.h" 
+#include "common.h"
 #include <time.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/tcp.h>
 
-/* 
+/*
   This function is used to modify the behavior of running client.
 
   We quit all connections so we can reset the sockets.
@@ -18,15 +18,12 @@
     ptr->flags&= ~temp_flag;
 }
 
-memcached_return memcached_behavior_set(memcached_st *ptr, 
-                                        memcached_behavior flag, 
+memcached_return memcached_behavior_set(memcached_st *ptr,
+                                        memcached_behavior flag,
                                         uint64_t data)
 {
   switch (flag)
   {
-  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:
-    ptr->number_of_replicas= (uint32_t)data;
-    break;
   case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:
     ptr->io_msg_watermark= (uint32_t) data;
     break;
@@ -38,18 +35,18 @@
     break;
   case MEMCACHED_BEHAVIOR_SND_TIMEOUT:
     ptr->snd_timeout= (int32_t)data;
-    break;     
+    break;
   case MEMCACHED_BEHAVIOR_RCV_TIMEOUT:
     ptr->rcv_timeout= (int32_t)data;
-    break;     
+    break;
   case MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT:
     ptr->server_failure_limit= (uint32_t)data;
-    break;     
+    break;
   case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:
     if (data)
         set_behavior_flag(ptr, MEM_VERIFY_KEY, 0);
     set_behavior_flag(ptr, MEM_BINARY_PROTOCOL, data);
-    break;     
+    break;
   case MEMCACHED_BEHAVIOR_SUPPORT_CAS:
     set_behavior_flag(ptr, MEM_SUPPORT_CAS, data);
     break;
@@ -169,15 +166,13 @@
   return MEMCACHED_SUCCESS;
 }
 
-uint64_t memcached_behavior_get(memcached_st *ptr, 
+uint64_t memcached_behavior_get(memcached_st *ptr,
                                 memcached_behavior flag)
 {
   memcached_flags temp_flag= MEM_NO_BLOCK;
 
   switch (flag)
   {
-  case MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS:
-    return ptr->number_of_replicas;
   case MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK:
     return ptr->io_msg_watermark;
   case MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK:
@@ -186,7 +181,7 @@
     return ptr->io_key_prefetch;
   case MEMCACHED_BEHAVIOR_BINARY_PROTOCOL:
     temp_flag= MEM_BINARY_PROTOCOL;
-    break;     
+    break;
   case MEMCACHED_BEHAVIOR_SUPPORT_CAS:
     temp_flag= MEM_SUPPORT_CAS;
     break;
@@ -244,7 +239,7 @@
       if ((memcached_connect(&ptr->hosts[0])) != MEMCACHED_SUCCESS)
         return 0;
 
-      if (getsockopt(ptr->hosts[0].fd, SOL_SOCKET, 
+      if (getsockopt(ptr->hosts[0].fd, SOL_SOCKET,
                      SO_SNDBUF, &sock_size, &sock_length))
         return 0; /* Zero means error */
 
@@ -260,7 +255,7 @@
       if ((memcached_connect(&ptr->hosts[0])) != MEMCACHED_SUCCESS)
         return 0;
 
-      if (getsockopt(ptr->hosts[0].fd, SOL_SOCKET, 
+      if (getsockopt(ptr->hosts[0].fd, SOL_SOCKET,
                      SO_RCVBUF, &sock_size, &sock_length))
         return 0; /* Zero means error */
 
diff -ur a/libmemcached-0.32/libmemcached/memcached_constants.h b/libmemcached-0.32/libmemcached/memcached_constants.h
--- a/libmemcached-0.32/libmemcached/memcached_constants.h	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached_constants.h	2011-03-02 21:45:46.000000000 -0800
@@ -104,8 +104,7 @@
   MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY,
   MEMCACHED_BEHAVIOR_NOREPLY,
   MEMCACHED_BEHAVIOR_USE_UDP,
-  MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS,
-  MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS
+  MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS
 } memcached_behavior;
 
 typedef enum {
diff -ur a/libmemcached-0.32/libmemcached/memcached_delete.c b/libmemcached-0.32/libmemcached/memcached_delete.c
--- a/libmemcached-0.32/libmemcached/memcached_delete.c	2009-07-29 22:47:46.000000000 -0700
+++ b/libmemcached-0.32/libmemcached/memcached_delete.c	2011-03-02 20:21:55.000000000 -0800
@@ -1,153 +0,0 @@
-#include "common.h"
-#include "memcached/protocol_binary.h"
-
-memcached_return memcached_delete(memcached_st *ptr, const char *key, size_t key_length,
-                                  time_t expiration)
-{
-  return memcached_delete_by_key(ptr, key, key_length,
-                                 key, key_length, expiration);
-}
-
-static inline memcached_return binary_delete(memcached_st *ptr, 
-                                             unsigned int server_key,
-                                             const char *key, 
-                                             size_t key_length,
-					     uint8_t flush);
-
-memcached_return memcached_delete_by_key(memcached_st *ptr, 
-                                         const char *master_key, size_t master_key_length,
-                                         const char *key, size_t key_length,
-                                         time_t expiration)
-{
-  uint8_t to_write;
-  size_t send_length;
-  memcached_return rc;
-  char buffer[MEMCACHED_DEFAULT_COMMAND_SIZE];
-  unsigned int server_key;
-
-  LIBMEMCACHED_MEMCACHED_DELETE_START();
-
-  rc= memcached_validate_key_length(key_length, 
-                                    ptr->flags & MEM_BINARY_PROTOCOL);
-  unlikely (rc != MEMCACHED_SUCCESS)
-    return rc;
-
-  unlikely (ptr->hosts == NULL || ptr->number_of_hosts == 0)
-    return MEMCACHED_NO_SERVERS;
-
-  server_key= memcached_generate_hash(ptr, master_key, master_key_length);
-  to_write= (uint8_t) (ptr->flags & MEM_BUFFER_REQUESTS) ? 0 : 1;
-  bool no_reply= (ptr->flags & MEM_NOREPLY);
-     
-  if (ptr->flags & MEM_BINARY_PROTOCOL) 
-    rc= binary_delete(ptr, server_key, key, key_length, to_write);
-  else 
-  {
-    if (expiration)
-      send_length= (size_t) snprintf(buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, 
-                                     "delete %s%.*s %u%s\r\n",
-                                     ptr->prefix_key,
-                                     (int) key_length, key, 
-                                     (uint32_t)expiration, no_reply ? " noreply" :"" );
-    else
-       send_length= (size_t) snprintf(buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, 
-                                      "delete %s%.*s%s\r\n",
-                                      ptr->prefix_key,
-                                      (int)key_length, key, no_reply ? " noreply" :"");
-    
-    if (send_length >= MEMCACHED_DEFAULT_COMMAND_SIZE) 
-    {
-      rc= MEMCACHED_WRITE_FAILURE;
-      goto error;
-    }
-
-    if (ptr->flags & MEM_USE_UDP && !to_write)
-    {
-      if (send_length > MAX_UDP_DATAGRAM_LENGTH - UDP_DATAGRAM_HEADER_LENGTH)
-        return MEMCACHED_WRITE_FAILURE;
-      if (send_length + ptr->hosts[server_key].write_buffer_offset > MAX_UDP_DATAGRAM_LENGTH)
-        memcached_io_write(&ptr->hosts[server_key], NULL, 0, 1);
-    }
-    
-    rc= memcached_do(&ptr->hosts[server_key], buffer, send_length, to_write);
-  }
-
-  if (rc != MEMCACHED_SUCCESS)
-    goto error;
-
-  if ((ptr->flags & MEM_BUFFER_REQUESTS))
-    rc= MEMCACHED_BUFFERED;
-  else if (!no_reply)
-  {
-    rc= memcached_response(&ptr->hosts[server_key], buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);
-    if (rc == MEMCACHED_DELETED)
-      rc= MEMCACHED_SUCCESS;
-  }
-
-  if (rc == MEMCACHED_SUCCESS && ptr->delete_trigger)
-    ptr->delete_trigger(ptr, key, key_length);
-
-error:
-  LIBMEMCACHED_MEMCACHED_DELETE_END();
-  return rc;
-}
-
-static inline memcached_return binary_delete(memcached_st *ptr, 
-                                             unsigned int server_key,
-                                             const char *key, 
-					     size_t key_length,
-					     uint8_t flush)
-{
-  protocol_binary_request_delete request= {.bytes= {0}};
-
-  request.message.header.request.magic= PROTOCOL_BINARY_REQ;
-  if (ptr->flags & MEM_NOREPLY)
-    request.message.header.request.opcode= PROTOCOL_BINARY_CMD_DELETEQ;
-  else
-    request.message.header.request.opcode= PROTOCOL_BINARY_CMD_DELETE;
-  request.message.header.request.keylen= htons((uint16_t)key_length);
-  request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-  request.message.header.request.bodylen= htonl((uint32_t) key_length);
-
-  if (ptr->flags & MEM_USE_UDP && !flush)
-  {
-    size_t cmd_size= sizeof(request.bytes) + key_length;
-    if (cmd_size > MAX_UDP_DATAGRAM_LENGTH - UDP_DATAGRAM_HEADER_LENGTH)
-      return MEMCACHED_WRITE_FAILURE;
-    if (cmd_size + ptr->hosts[server_key].write_buffer_offset > MAX_UDP_DATAGRAM_LENGTH)
-      memcached_io_write(&ptr->hosts[server_key], NULL, 0, 1);
-  }
-  
-  memcached_return rc= MEMCACHED_SUCCESS;
-
-  if ((memcached_do(&ptr->hosts[server_key], request.bytes, 
-                    sizeof(request.bytes), 0) != MEMCACHED_SUCCESS) ||
-      (memcached_io_write(&ptr->hosts[server_key], key, 
-                          key_length, (char) flush) == -1)) 
-  {
-    memcached_io_reset(&ptr->hosts[server_key]);
-    rc= MEMCACHED_WRITE_FAILURE;
-  }
-
-  unlikely (ptr->number_of_replicas > 0) 
-  {
-    request.message.header.request.opcode= PROTOCOL_BINARY_CMD_DELETEQ;
-
-    for (uint32_t x= 0; x < ptr->number_of_replicas; ++x)
-    {
-      ++server_key;
-      if (server_key == ptr->number_of_hosts)
-        server_key= 0;
-  
-      memcached_server_st* server= &ptr->hosts[server_key];
-      if ((memcached_do(server, (const char*)request.bytes, 
-                        sizeof(request.bytes), 0) != MEMCACHED_SUCCESS) ||
-          (memcached_io_write(server, key, key_length, (char) flush) == -1))
-        memcached_io_reset(server);
-      else
-        memcached_server_response_decrement(server);
-    }
-  }
-
-  return rc;
-}
diff -ur a/libmemcached-0.32/libmemcached/memcached_get.c b/libmemcached-0.32/libmemcached/memcached_get.c
--- a/libmemcached-0.32/libmemcached/memcached_get.c	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached_get.c	2011-03-02 22:32:11.000000000 -0800
@@ -1,12 +1,12 @@
 #include "common.h"
 #include "memcached_io.h"
 
-/* 
+/*
   What happens if no servers exist?
 */
-char *memcached_get(memcached_st *ptr, const char *key, 
-                    size_t key_length, 
-                    size_t *value_length, 
+char *memcached_get(memcached_st *ptr, const char *key,
+                    size_t key_length,
+                    size_t *value_length,
                     uint32_t *flags,
                     memcached_return *error)
 {
@@ -15,25 +15,25 @@
                               flags, error);
 }
 
-char *memcached_get_len(memcached_st *ptr, 
+char *memcached_get_len(memcached_st *ptr,
                         const char *key, size_t key_length,
                         uint32_t user_spec_len,
-                        size_t *value_length, 
+                        size_t *value_length,
                         uint32_t *flags,
                         memcached_return *error)
 {
   return memcached_get_by_key(ptr, NULL, 0, key, key_length,
-                              user_spec_len, value_length, 
+                              user_spec_len, value_length,
                               flags, error);
 
 }
 
-char *memcached_get_by_key(memcached_st *ptr, 
-                           const char *master_key, 
-                           size_t master_key_length, 
+char *memcached_get_by_key(memcached_st *ptr,
+                           const char *master_key,
+                           size_t master_key_length,
                            const char *key, size_t key_length,
                            uint32_t user_spec_len,
-                           size_t *value_length, 
+                           size_t *value_length,
                            uint32_t *flags,
                            memcached_return *error)
 {
@@ -49,13 +49,13 @@
   }
 
   /* Request the key */
-  *error= memcached_mget_by_key(ptr, 
-                                master_key, 
-                                master_key_length, 
+  *error= memcached_mget_by_key(ptr,
+                                master_key,
+                                master_key_length,
                                 (const char **)&key, &key_length, 1,
                                 user_spec_len);
 
-  value= memcached_fetch(ptr, NULL, NULL, 
+  value= memcached_fetch(ptr, NULL, NULL,
                          value_length, flags, error);
   /* This is for historical reasons */
   if (*error == MEMCACHED_END)
@@ -69,7 +69,7 @@
 
       memcached_result_reset(&ptr->result);
       rc= ptr->get_key_failure(ptr, key, key_length, &ptr->result);
-      
+
       /* On all failure drop to returning NULL */
       if (rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED)
       {
@@ -80,7 +80,7 @@
           if (latch == 0)
             memcached_behavior_set(ptr, MEMCACHED_BEHAVIOR_BUFFER_REQUESTS, 1);
 
-          rc= memcached_set(ptr, key, key_length, 
+          rc= memcached_set(ptr, key, key_length,
                             memcached_result_value(&ptr->result),
                             memcached_result_length(&ptr->result),
                             0, memcached_result_flags(&ptr->result));
@@ -90,7 +90,7 @@
         }
         else
         {
-          rc= memcached_set(ptr, key, key_length, 
+          rc= memcached_set(ptr, key, key_length,
                             memcached_result_value(&ptr->result),
                             memcached_result_length(&ptr->result),
                             0, memcached_result_flags(&ptr->result));
@@ -109,24 +109,24 @@
     return NULL;
   }
 
-  (void)memcached_fetch(ptr, NULL, NULL, 
-                        &dummy_length, &dummy_flags, 
+  (void)memcached_fetch(ptr, NULL, NULL,
+                        &dummy_length, &dummy_flags,
                         &dummy_error);
   WATCHPOINT_ASSERT(dummy_length == 0);
 
   return value;
 }
 
-memcached_return memcached_mget(memcached_st *ptr, 
-                                const char **keys, size_t *key_length, 
+memcached_return memcached_mget(memcached_st *ptr,
+                                const char **keys, size_t *key_length,
                                 size_t number_of_keys)
 {
   return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys,
                                GET_LEN_ARG_UNSPECIFIED);
 }
 
-memcached_return memcached_mget_len(memcached_st *ptr, 
-                                    const char **keys, size_t *key_length, 
+memcached_return memcached_mget_len(memcached_st *ptr,
+                                    const char **keys, size_t *key_length,
                                     size_t number_of_keys, uint32_t user_spec_len)
 {
   return memcached_mget_by_key(ptr, NULL, 0, keys, key_length, number_of_keys,
@@ -145,11 +145,11 @@
   return (user_spec_len > 0 && user_spec_len < GET_LEN_ARG_UNSPECIFIED);
 }
 
-memcached_return memcached_mget_by_key(memcached_st *ptr, 
-                                       const char *master_key, 
+memcached_return memcached_mget_by_key(memcached_st *ptr,
+                                       const char *master_key,
                                        size_t master_key_length,
-                                       const char **keys, 
-                                       size_t *key_length, 
+                                       const char **keys,
+                                       size_t *key_length,
                                        size_t number_of_keys,
                                        uint32_t user_spec_len)
 {
@@ -193,7 +193,7 @@
       return MEMCACHED_FAILURE;
   }
 
-  /* 
+  /*
     Here is where we pay for the non-block API. We need to remove any data sitting
     in the queue before we start our get.
 
@@ -212,13 +212,13 @@
         (void)memcached_response(&ptr->hosts[x], buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, &ptr->result);
     }
   }
-  
+
   if (ptr->flags & MEM_BINARY_PROTOCOL)
-    return binary_mget_by_key(ptr, master_server_key, is_master_key_set, keys, 
+    return binary_mget_by_key(ptr, master_server_key, is_master_key_set, keys,
                               key_length, number_of_keys);
 
   if (length_specified) {
-    if (use_cas) 
+    if (use_cas)
     {
       get_command= "gets_len ";
       get_command_length= 9;
@@ -227,7 +227,7 @@
       get_command_length= 8;
     }
   } else {
-    if (use_cas) 
+    if (use_cas)
     {
       get_command= "gets ";
       get_command_length= 5;
@@ -237,7 +237,7 @@
     }
   }
 
-  /* 
+  /*
     If a server fails we warn about errors and start all over with sending keys
     to the server.
   */
@@ -302,7 +302,7 @@
       rc= MEMCACHED_SOME_ERRORS;
       continue;
     }
-    
+
     ptr->last_server_key = server_key;
   }
 
@@ -329,7 +329,7 @@
 char *memcached_get_from_last(memcached_st *ptr,
                               const char *key,
                               size_t key_length,
-                              size_t *value_length, 
+                              size_t *value_length,
                               uint32_t *flags,
                               memcached_return *error)
 {
@@ -384,8 +384,8 @@
     uint32_t dummy_flags;
     memcached_return dummy_error;
 
-    (void)memcached_fetch(ptr, NULL, NULL, 
-                          &dummy_length, &dummy_flags, 
+    (void)memcached_fetch(ptr, NULL, NULL,
+                          &dummy_length, &dummy_flags,
                           &dummy_error);
     WATCHPOINT_ASSERT(dummy_length == 0);
   }
@@ -393,10 +393,10 @@
   return value;
 }
 
-static memcached_return simple_binary_mget(memcached_st *ptr,
+static memcached_return binary_mget_by_key(memcached_st *ptr,
                                            unsigned int master_server_key,
                                            bool is_master_key_set,
-                                           const char **keys, size_t *key_length, 
+                                           const char **keys, size_t *key_length,
                                            size_t number_of_keys)
 {
   memcached_return rc= MEMCACHED_NOTFOUND;
@@ -404,11 +404,11 @@
 
   int flush= number_of_keys == 1;
 
-  /* 
+  /*
     If a server fails we warn about errors and start all over with sending keys
     to the server.
   */
-  for (x= 0; x < number_of_keys; x++) 
+  for (x= 0; x < number_of_keys; x++)
   {
     unsigned int server_key;
 
@@ -417,13 +417,13 @@
     else
       server_key= memcached_generate_hash(ptr, keys[x], key_length[x]);
 
-    if (memcached_server_response_count(&ptr->hosts[server_key]) == 0) 
+    if (memcached_server_response_count(&ptr->hosts[server_key]) == 0)
     {
       rc= memcached_connect(&ptr->hosts[server_key]);
-      if (rc != MEMCACHED_SUCCESS) 
+      if (rc != MEMCACHED_SUCCESS)
         continue;
     }
-     
+
     protocol_binary_request_getk request= {.bytes= {0}};
     request.message.header.request.magic= PROTOCOL_BINARY_REQ;
     if (number_of_keys == 1)
@@ -432,7 +432,7 @@
       request.message.header.request.opcode= PROTOCOL_BINARY_CMD_GETKQ;
 
     memcached_return vk;
-    vk= memcached_validate_key_length(key_length[x],
+    vk= memcached_validate_key_length(ptr->prefix_key_length + key_length[x],
                                       ptr->flags & MEM_BINARY_PROTOCOL);
     unlikely (vk != MEMCACHED_SUCCESS)
     {
@@ -441,26 +441,28 @@
       return vk;
     }
 
-    request.message.header.request.keylen= htons((uint16_t)key_length[x]);
+    request.message.header.request.keylen= htons((uint16_t)(ptr->prefix_key_length + key_length[x]));
     request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-    request.message.header.request.bodylen= htonl((uint32_t) key_length[x]);
-    
+    request.message.header.request.bodylen= htonl((uint32_t) (ptr->prefix_key_length + key_length[x]));
+
     if ((memcached_io_write(&ptr->hosts[server_key], request.bytes,
                             sizeof(request.bytes), 0) == -1) ||
-        (memcached_io_write(&ptr->hosts[server_key], keys[x], 
-                            key_length[x], (char) flush) == -1)) 
+        (memcached_io_write(&ptr->hosts[server_key], ptr->prefix_key,
+                            ptr->prefix_key_length, 0) == -1) ||
+        (memcached_io_write(&ptr->hosts[server_key], keys[x],
+                            key_length[x], (char) flush) == -1))
     {
       memcached_server_response_reset(&ptr->hosts[server_key]);
       rc= MEMCACHED_SOME_ERRORS;
       continue;
     }
-    memcached_server_response_increment(&ptr->hosts[server_key]);    
+    memcached_server_response_increment(&ptr->hosts[server_key]);
     if ((x > 0 && x == ptr->io_key_prefetch) &&
         memcached_flush_buffers(ptr) != MEMCACHED_SUCCESS)
       rc= MEMCACHED_SOME_ERRORS;
   }
 
-  if (number_of_keys > 1) 
+  if (number_of_keys > 1)
   {
     /*
      * Send a noop command to flush the buffers
@@ -469,173 +471,28 @@
     request.message.header.request.magic= PROTOCOL_BINARY_REQ;
     request.message.header.request.opcode= PROTOCOL_BINARY_CMD_NOOP;
     request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-    
+
     for (x= 0; x < ptr->number_of_hosts; x++)
-      if (memcached_server_response_count(&ptr->hosts[x])) 
+      if (memcached_server_response_count(&ptr->hosts[x]))
       {
-        if (memcached_io_write(&ptr->hosts[x], NULL, 0, 1) == -1) 
+        if (memcached_io_write(&ptr->hosts[x], NULL, 0, 1) == -1)
         {
           memcached_server_response_reset(&ptr->hosts[x]);
           memcached_io_reset(&ptr->hosts[x]);
           rc= MEMCACHED_SOME_ERRORS;
         }
 
-        if (memcached_io_write(&ptr->hosts[x], request.bytes, 
-			       sizeof(request.bytes), 1) == -1) 
+        if (memcached_io_write(&ptr->hosts[x], request.bytes,
+			       sizeof(request.bytes), 1) == -1)
         {
           memcached_server_response_reset(&ptr->hosts[x]);
           memcached_io_reset(&ptr->hosts[x]);
           rc= MEMCACHED_SOME_ERRORS;
         }
-        memcached_server_response_increment(&ptr->hosts[x]);    
-      }
-    }
-
-
-  return rc;
-}
-
-static memcached_return replication_binary_mget(memcached_st *ptr,
-                                             uint32_t* hash, bool* dead_servers,
-                                             const char **keys, size_t *key_length,
-                                             size_t number_of_keys)
-{
-  memcached_return rc= MEMCACHED_NOTFOUND;
-  uint32_t x;
-
-  int flush= number_of_keys == 1;
-
-  for (uint32_t replica= 0; replica <= ptr->number_of_replicas; ++replica)
-  {
-    bool success= true;    
-    
-    for (x= 0; x < number_of_keys; ++x)
-    {
-      if (hash[x] == ptr->number_of_hosts)
-        continue; /* Already successfully sent */
-
-      uint32_t server= hash[x] + replica;
-      while (server >= ptr->number_of_hosts)
-        server -= ptr->number_of_hosts;
-
-      if (dead_servers[server])
-        continue;
-
-      if (memcached_server_response_count(&ptr->hosts[server]) == 0)
-      {
-        rc= memcached_connect(&ptr->hosts[server]);
-        if (rc != MEMCACHED_SUCCESS)
-        {
-          memcached_io_reset(&ptr->hosts[server]);
-          dead_servers[server]= true;
-          success= false;
-          continue;
-        }
+        memcached_server_response_increment(&ptr->hosts[x]);
       }
-
-      protocol_binary_request_getk request= {.bytes= {0}};
-      request.message.header.request.magic= PROTOCOL_BINARY_REQ;
-      if (number_of_keys == 1)
-        request.message.header.request.opcode= PROTOCOL_BINARY_CMD_GETK;
-      else
-        request.message.header.request.opcode= PROTOCOL_BINARY_CMD_GETKQ;
-
-      request.message.header.request.keylen= htons((uint16_t)key_length[x]);
-      request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-      request.message.header.request.bodylen= htonl((uint32_t) key_length[x]);
-
-      if ((memcached_io_write(&ptr->hosts[server], request.bytes,
-                              sizeof(request.bytes), 0) == -1) ||
-          (memcached_io_write(&ptr->hosts[server], keys[x],
-                              key_length[x], (char) flush) == -1))
-      {
-        memcached_io_reset(&ptr->hosts[server]);
-        dead_servers[server]= true;
-        success= false;
-        continue;
-      }
-      memcached_server_response_increment(&ptr->hosts[server]);
-    }
-
-    if (number_of_keys > 1)
-    {
-      /*
-       * Send a noop command to flush the buffers
-       */
-      protocol_binary_request_noop request= {.bytes= {0}};
-      request.message.header.request.magic= PROTOCOL_BINARY_REQ;
-      request.message.header.request.opcode= PROTOCOL_BINARY_CMD_NOOP;
-      request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-
-      for (x= 0; x < ptr->number_of_hosts; x++)
-        if (memcached_server_response_count(&ptr->hosts[x]))
-        {
-          if (memcached_io_write(&ptr->hosts[x], request.bytes,
-                                 sizeof(request.bytes), 1) == -1)
-          {
-            memcached_io_reset(&ptr->hosts[x]);
-            dead_servers[x]= true;
-            success= false;
-          }
-          memcached_server_response_increment(&ptr->hosts[x]);
-
-          /* mark all of the messages bound for this server as sent! */
-          for (x= 0; x < number_of_keys; ++x)
-            if (hash[x] == x)
-              hash[x]= ptr->number_of_hosts;
-        }
     }
 
-    if (success)
-      break;
-  }
-
-  return rc;
-}
-
-static memcached_return binary_mget_by_key(memcached_st *ptr,
-                                           unsigned int master_server_key,
-                                           bool is_master_key_set,
-                                           const char **keys, size_t *key_length,
-                                           size_t number_of_keys)
-{
-  memcached_return rc;
-
-  if (ptr->number_of_replicas == 0) 
-  {
-    rc= simple_binary_mget(ptr, master_server_key, is_master_key_set,
-                           keys, key_length, number_of_keys);
-  } 
-  else 
-  {
-    uint32_t* hash;
-    bool* dead_servers;
-
-    hash= ptr->call_malloc(ptr, sizeof(uint32_t) * number_of_keys);
-    dead_servers= ptr->call_calloc(ptr, ptr->number_of_hosts, sizeof(bool));
-
-    if (hash == NULL || dead_servers == NULL)
-    {
-      ptr->call_free(ptr, hash);
-      ptr->call_free(ptr, dead_servers);
-      return MEMCACHED_MEMORY_ALLOCATION_FAILURE;
-    }
-
-    if (is_master_key_set)
-      for (unsigned int x= 0; x < number_of_keys; x++)
-        hash[x]= master_server_key;
-    else
-      for (unsigned int x= 0; x < number_of_keys; x++)
-        hash[x]= memcached_generate_hash(ptr, keys[x], key_length[x]);
-
-    rc= replication_binary_mget(ptr, hash, dead_servers, keys, 
-                                key_length, number_of_keys);
-
-    ptr->call_free(ptr, hash);
-    ptr->call_free(ptr, dead_servers);
-
-    return MEMCACHED_SUCCESS;
-  }
 
   return rc;
 }
diff -ur a/libmemcached-0.32/libmemcached/memcached_hash.c b/libmemcached-0.32/libmemcached/memcached_hash.c
--- a/libmemcached-0.32/libmemcached/memcached_hash.c	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached_hash.c	2011-03-02 21:44:00.000000000 -0800
@@ -32,13 +32,13 @@
       hash= 1;
     break;
     /* FNV hash'es lifted from Dustin Sallings work */
-  case MEMCACHED_HASH_FNV1_64: 
+  case MEMCACHED_HASH_FNV1_64:
     {
       /* Thanks to pierre@demartines.com for the pointer */
       uint64_t temp_hash;
 
       temp_hash= FNV_64_INIT;
-      for (x= 0; x < key_length; x++) 
+      for (x= 0; x < key_length; x++)
       {
         temp_hash *= FNV_64_PRIME;
         temp_hash ^= (uint64_t)key[x];
@@ -46,10 +46,10 @@
       hash= (uint32_t)temp_hash;
     }
     break;
-  case MEMCACHED_HASH_FNV1A_64: 
+  case MEMCACHED_HASH_FNV1A_64:
     {
       hash= (uint32_t) FNV_64_INIT;
-      for (x= 0; x < key_length; x++) 
+      for (x= 0; x < key_length; x++)
       {
         uint32_t val= (uint32_t)key[x];
         hash ^= val;
@@ -57,10 +57,10 @@
       }
     }
     break;
-  case MEMCACHED_HASH_FNV1_32: 
+  case MEMCACHED_HASH_FNV1_32:
     {
       hash= FNV_32_INIT;
-      for (x= 0; x < key_length; x++) 
+      for (x= 0; x < key_length; x++)
       {
         uint32_t val= (uint32_t)key[x];
         hash *= FNV_32_PRIME;
@@ -68,10 +68,10 @@
       }
     }
     break;
-  case MEMCACHED_HASH_FNV1A_32: 
+  case MEMCACHED_HASH_FNV1A_32:
     {
       hash= FNV_32_INIT;
-      for (x= 0; x < key_length; x++) 
+      for (x= 0; x < key_length; x++)
       {
         uint32_t val= (uint32_t)key[x];
         hash ^= val;
@@ -127,7 +127,7 @@
 
 static uint32_t dispatch_host(memcached_st *ptr, uint32_t hash)
 {
-  switch (ptr->distribution) 
+  switch (ptr->distribution)
   {
   case MEMCACHED_DISTRIBUTION_CONSISTENT:
   case MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA:
@@ -151,8 +151,8 @@
       if (right == end)
         right= begin;
       return right->index;
-    } 
-  case MEMCACHED_DISTRIBUTION_MODULA:  
+    }
+  case MEMCACHED_DISTRIBUTION_MODULA:
     return memcached_live_host_index(ptr, hash);
   case MEMCACHED_DISTRIBUTION_RANDOM:
     return memcached_live_host_index(ptr, (uint32_t) random());
@@ -164,8 +164,8 @@
   /* NOTREACHED */
 }
 
-/* 
-  One day make this public, and have it return the actual memcached_server_st 
+/*
+  One day make this public, and have it return the actual memcached_server_st
   to the calling application.
 */
 uint32_t memcached_generate_hash(memcached_st *ptr, const char *key, size_t key_length)
@@ -225,7 +225,7 @@
   const char *ptr= key;
   uint32_t value= 0;
 
-  while (key_length--) 
+  while (key_length--)
   {
     uint32_t val= (uint32_t) *ptr++;
     value += val;
@@ -234,7 +234,7 @@
   }
   value += (value << 3);
   value ^= (value >> 11);
-  value += (value << 15); 
+  value += (value << 15);
 
   return value == 0 ? 1 : (uint32_t) value;
 }
diff -ur a/libmemcached-0.32/libmemcached/memcached_storage.c b/libmemcached-0.32/libmemcached/memcached_storage.c
--- a/libmemcached-0.32/libmemcached/memcached_storage.c	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/libmemcached/memcached_storage.c	2011-03-02 22:09:56.000000000 -0800
@@ -16,6 +16,7 @@
   PREPEND_OP,
   APPEND_OP,
   CAS_OP,
+  DELETE_OP,
 } memcached_storage_action;
 
 /* Inline this */
@@ -25,6 +26,8 @@
   {
   case SET_OP:
     return "set ";
+  case DELETE_OP:
+    return "delete ";
   case REPLACE_OP:
     return "replace ";
   case ADD_OP:
@@ -43,21 +46,21 @@
 }
 
 static memcached_return memcached_send_binary(memcached_st *ptr,
-                                              const char *master_key, 
+                                              const char *master_key,
                                               size_t master_key_length,
-                                              const char *key, 
-                                              size_t key_length, 
-                                              const char *value, 
-                                              size_t value_length, 
+                                              const char *key,
+                                              size_t key_length,
+                                              const char *value,
+                                              size_t value_length,
                                               time_t expiration,
                                               uint32_t flags,
                                               uint64_t cas,
                                               memcached_storage_action verb);
 
-static inline memcached_return memcached_send(memcached_st *ptr, 
-                                              const char *master_key, size_t master_key_length, 
-                                              const char *key, size_t key_length, 
-                                              const char *value, size_t value_length, 
+static inline memcached_return memcached_send(memcached_st *ptr,
+                                              const char *master_key, size_t master_key_length,
+                                              const char *key, size_t key_length,
+                                              const char *value, size_t value_length,
                                               time_t expiration,
                                               uint32_t flags,
                                               uint64_t cas,
@@ -75,7 +78,7 @@
   rc= memcached_validate_key_length(key_length, ptr->flags & MEM_BINARY_PROTOCOL);
   unlikely (rc != MEMCACHED_SUCCESS)
     return rc;
-  
+
   unlikely (ptr->number_of_hosts == 0)
     return MEMCACHED_NO_SERVERS;
 
@@ -91,12 +94,12 @@
   server_key= memcached_generate_hash(ptr, master_key, master_key_length);
 
   if (cas)
-    write_length= (size_t) snprintf(buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, 
-                                    "%s %s%.*s %u %llu %zu %llu%s\r\n", 
+    write_length= (size_t) snprintf(buffer, MEMCACHED_DEFAULT_COMMAND_SIZE,
+                                    "%s %s%.*s %u %llu %zu %llu%s\r\n",
                                     storage_op_string(verb),
                                     ptr->prefix_key,
-                                    (int)key_length, key, flags, 
-                                    (unsigned long long)expiration, value_length, 
+                                    (int)key_length, key, flags,
+                                    (unsigned long long)expiration, value_length,
                                     (unsigned long long)cas,
                                     (ptr->flags & MEM_NOREPLY) ? " noreply" : "");
   else
@@ -111,18 +114,23 @@
     buffer_ptr= memcpy(buffer_ptr + strlen(command) , ptr->prefix_key, strlen(ptr->prefix_key));
 
     /* Copy in the key, adjust point if a key prefix was used. */
-    buffer_ptr= memcpy(buffer_ptr + (ptr->prefix_key ? strlen(ptr->prefix_key) : 0), 
+    buffer_ptr= memcpy(buffer_ptr + (ptr->prefix_key ? strlen(ptr->prefix_key) : 0),
                        key, key_length);
     buffer_ptr+= key_length;
-    buffer_ptr[0]=  ' '; 
+    buffer_ptr[0]=  ' ';
     buffer_ptr++;
-
     write_length= (size_t)(buffer_ptr - buffer);
-    write_length+= (size_t) snprintf(buffer_ptr, MEMCACHED_DEFAULT_COMMAND_SIZE, 
-                                     "%u %llu %zu%s\r\n", 
-                                     flags, 
-                                     (unsigned long long)expiration, value_length,
-                                     (ptr->flags & MEM_NOREPLY) ? " noreply" : "");
+
+    if (verb == DELETE_OP) {
+      if (ptr->flags & MEM_NOREPLY)
+        write_length+= (size_t) snprintf(buffer_ptr, MEMCACHED_DEFAULT_COMMAND_SIZE, "noreply");
+    } else {
+      write_length+= (size_t) snprintf(buffer_ptr, MEMCACHED_DEFAULT_COMMAND_SIZE,
+                                       "%u %llu %zu%s\r\n",
+                                       flags,
+                                       (unsigned long long)expiration, value_length,
+                                       (ptr->flags & MEM_NOREPLY) ? " noreply" : "");
+    }
   }
 
   if (ptr->flags & MEM_USE_UDP && ptr->flags & MEM_BUFFER_REQUESTS)
@@ -147,7 +155,7 @@
     return MEMCACHED_WRITE_FAILURE;
 
   if ((ptr->flags & MEM_BUFFER_REQUESTS) &&
-      (verb == SET_OP || verb == PREPEND_OP || verb == APPEND_OP))
+      (verb == SET_OP || verb == PREPEND_OP || verb == APPEND_OP || verb == DELETE_OP))
     to_write= 0;
   else
     to_write= 1;
@@ -162,183 +170,210 @@
     return MEMCACHED_BUFFERED;
 
   rc= memcached_response(&ptr->hosts[server_key], buffer, MEMCACHED_DEFAULT_COMMAND_SIZE, NULL);
-  if (rc == MEMCACHED_STORED)
-    return MEMCACHED_SUCCESS;  
+  if (rc == MEMCACHED_STORED || rc == MEMCACHED_DELETED)
+    return MEMCACHED_SUCCESS;
+
   return rc;
 }
 
 
-memcached_return memcached_set(memcached_st *ptr, const char *key, size_t key_length, 
-                               const char *value, size_t value_length, 
+memcached_return memcached_set(memcached_st *ptr, const char *key, size_t key_length,
+                               const char *value, size_t value_length,
                                time_t expiration,
                                uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_SET_START();
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, SET_OP);
   LIBMEMCACHED_MEMCACHED_SET_END();
   return rc;
 }
 
-memcached_return memcached_add(memcached_st *ptr, 
+memcached_return memcached_delete(memcached_st *ptr, const char *key, size_t key_length,
+                                  time_t expiration)
+{
+  memcached_return rc;
+  LIBMEMCACHED_MEMCACHED_DELETE_START();
+  rc= memcached_send(ptr, key, key_length,
+                     key, key_length, "", 0,
+                     expiration, 0, 0, DELETE_OP);
+  LIBMEMCACHED_MEMCACHED_DELETE_END();
+  return rc;
+}
+
+memcached_return memcached_delete_by_key(memcached_st *ptr,
+                                         const char *master_key, size_t master_key_length,
+                                         const char *key, size_t key_length,
+                                         time_t expiration)
+{
+  memcached_return rc;
+  LIBMEMCACHED_MEMCACHED_DELETE_START();
+  rc= memcached_send(ptr, master_key, master_key_length,
+                     key, key_length, "", 0,
+                     expiration, 0, 0, DELETE_OP);
+  LIBMEMCACHED_MEMCACHED_DELETE_END();
+  return rc;
+}
+
+memcached_return memcached_add(memcached_st *ptr,
                                const char *key, size_t key_length,
-                               const char *value, size_t value_length, 
+                               const char *value, size_t value_length,
                                time_t expiration,
                                uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_ADD_START();
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, ADD_OP);
   LIBMEMCACHED_MEMCACHED_ADD_END();
   return rc;
 }
 
-memcached_return memcached_replace(memcached_st *ptr, 
+memcached_return memcached_replace(memcached_st *ptr,
                                    const char *key, size_t key_length,
-                                   const char *value, size_t value_length, 
+                                   const char *value, size_t value_length,
                                    time_t expiration,
                                    uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_REPLACE_START();
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, REPLACE_OP);
   LIBMEMCACHED_MEMCACHED_REPLACE_END();
   return rc;
 }
 
-memcached_return memcached_prepend(memcached_st *ptr, 
+memcached_return memcached_prepend(memcached_st *ptr,
                                    const char *key, size_t key_length,
-                                   const char *value, size_t value_length, 
+                                   const char *value, size_t value_length,
                                    time_t expiration,
                                    uint32_t flags)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, PREPEND_OP);
   return rc;
 }
 
-memcached_return memcached_append(memcached_st *ptr, 
+memcached_return memcached_append(memcached_st *ptr,
                                   const char *key, size_t key_length,
-                                  const char *value, size_t value_length, 
+                                  const char *value, size_t value_length,
                                   time_t expiration,
                                   uint32_t flags)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, APPEND_OP);
   return rc;
 }
 
-memcached_return memcached_cas(memcached_st *ptr, 
+memcached_return memcached_cas(memcached_st *ptr,
                                const char *key, size_t key_length,
-                               const char *value, size_t value_length, 
+                               const char *value, size_t value_length,
                                time_t expiration,
                                uint32_t flags,
                                uint64_t cas)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, key, key_length, 
+  rc= memcached_send(ptr, key, key_length,
                      key, key_length, value, value_length,
                      expiration, flags, cas, CAS_OP);
   return rc;
 }
 
-memcached_return memcached_set_by_key(memcached_st *ptr, 
-                                      const char *master_key __attribute__((unused)), 
-                                      size_t master_key_length __attribute__((unused)), 
-                                      const char *key, size_t key_length, 
-                                      const char *value, size_t value_length, 
+memcached_return memcached_set_by_key(memcached_st *ptr,
+                                      const char *master_key __attribute__((unused)),
+                                      size_t master_key_length __attribute__((unused)),
+                                      const char *key, size_t key_length,
+                                      const char *value, size_t value_length,
                                       time_t expiration,
                                       uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_SET_START();
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, SET_OP);
   LIBMEMCACHED_MEMCACHED_SET_END();
   return rc;
 }
 
-memcached_return memcached_add_by_key(memcached_st *ptr, 
+memcached_return memcached_add_by_key(memcached_st *ptr,
                                       const char *master_key, size_t master_key_length,
                                       const char *key, size_t key_length,
-                                      const char *value, size_t value_length, 
+                                      const char *value, size_t value_length,
                                       time_t expiration,
                                       uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_ADD_START();
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, ADD_OP);
   LIBMEMCACHED_MEMCACHED_ADD_END();
   return rc;
 }
 
-memcached_return memcached_replace_by_key(memcached_st *ptr, 
+memcached_return memcached_replace_by_key(memcached_st *ptr,
                                           const char *master_key, size_t master_key_length,
                                           const char *key, size_t key_length,
-                                          const char *value, size_t value_length, 
+                                          const char *value, size_t value_length,
                                           time_t expiration,
                                           uint32_t flags)
 {
   memcached_return rc;
   LIBMEMCACHED_MEMCACHED_REPLACE_START();
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, REPLACE_OP);
   LIBMEMCACHED_MEMCACHED_REPLACE_END();
   return rc;
 }
 
-memcached_return memcached_prepend_by_key(memcached_st *ptr, 
+memcached_return memcached_prepend_by_key(memcached_st *ptr,
                                           const char *master_key, size_t master_key_length,
                                           const char *key, size_t key_length,
-                                          const char *value, size_t value_length, 
+                                          const char *value, size_t value_length,
                                           time_t expiration,
                                           uint32_t flags)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, PREPEND_OP);
   return rc;
 }
 
-memcached_return memcached_append_by_key(memcached_st *ptr, 
+memcached_return memcached_append_by_key(memcached_st *ptr,
                                          const char *master_key, size_t master_key_length,
                                          const char *key, size_t key_length,
-                                         const char *value, size_t value_length, 
+                                         const char *value, size_t value_length,
                                          time_t expiration,
                                          uint32_t flags)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, 0, APPEND_OP);
   return rc;
 }
 
-memcached_return memcached_cas_by_key(memcached_st *ptr, 
+memcached_return memcached_cas_by_key(memcached_st *ptr,
                                       const char *master_key, size_t master_key_length,
                                       const char *key, size_t key_length,
-                                      const char *value, size_t value_length, 
+                                      const char *value, size_t value_length,
                                       time_t expiration,
                                       uint32_t flags,
                                       uint64_t cas)
 {
   memcached_return rc;
-  rc= memcached_send(ptr, master_key, master_key_length, 
+  rc= memcached_send(ptr, master_key, master_key_length,
                      key, key_length, value, value_length,
                      expiration, flags, cas, CAS_OP);
   return rc;
@@ -356,6 +391,9 @@
     case SET_OP:
       ret=PROTOCOL_BINARY_CMD_SETQ;
       break;
+    case DELETE_OP:
+      ret=PROTOCOL_BINARY_CMD_DELETEQ;
+      break;
     case ADD_OP:
       ret=PROTOCOL_BINARY_CMD_ADDQ;
       break;
@@ -379,6 +417,9 @@
     case SET_OP:
       ret=PROTOCOL_BINARY_CMD_SET;
       break;
+    case DELETE_OP:
+      ret=PROTOCOL_BINARY_CMD_DELETE;
+      break;
     case ADD_OP:
       ret=PROTOCOL_BINARY_CMD_ADD;
       break;
@@ -403,12 +444,12 @@
 
 
 static memcached_return memcached_send_binary(memcached_st *ptr,
-                                              const char *master_key, 
+                                              const char *master_key,
                                               size_t master_key_length,
                                               const char *key,
-                                              size_t key_length, 
-                                              const char *value, 
-                                              size_t value_length, 
+                                              size_t key_length,
+                                              const char *value,
+                                              size_t value_length,
                                               time_t expiration,
                                               uint32_t flags,
                                               uint64_t cas,
@@ -417,77 +458,57 @@
   uint8_t flush;
   protocol_binary_request_set request= {.bytes= {0}};
   size_t send_length= sizeof(request.bytes);
-  uint32_t server_key= memcached_generate_hash(ptr, master_key, 
+  uint32_t server_key= memcached_generate_hash(ptr, master_key,
                                                master_key_length);
   memcached_server_st *server= &ptr->hosts[server_key];
   bool noreply= server->root->flags & MEM_NOREPLY;
 
   request.message.header.request.magic= PROTOCOL_BINARY_REQ;
   request.message.header.request.opcode= get_com_code(verb, noreply);
-  request.message.header.request.keylen= htons((uint16_t)key_length);
+  request.message.header.request.keylen= htons((uint16_t)(ptr->prefix_key_length + key_length));
   request.message.header.request.datatype= PROTOCOL_BINARY_RAW_BYTES;
-  if (verb == APPEND_OP || verb == PREPEND_OP)
-    send_length -= 8; /* append & prepend does not contain extras! */
-  else 
+  if (verb == APPEND_OP || verb == PREPEND_OP || verb == DELETE_OP)
+    send_length -= 8; /* append, delete, and prepend do not contain extras! */
+  else
   {
     request.message.header.request.extlen= 8;
-    request.message.body.flags= htonl(flags);   
+    request.message.body.flags= htonl(flags);
     request.message.body.expiration= htonl((uint32_t)expiration);
   }
-  
-  request.message.header.request.bodylen= htonl((uint32_t) (key_length + value_length + 
+
+  request.message.header.request.bodylen= htonl((uint32_t) (ptr->prefix_key_length + key_length + value_length +
 						request.message.header.request.extlen));
-  
+
   if (cas)
     request.message.header.request.cas= htonll(cas);
-  
+
   flush= (uint8_t) (((server->root->flags & MEM_BUFFER_REQUESTS) && verb == SET_OP) ? 0 : 1);
 
   if ((server->root->flags & MEM_USE_UDP) && !flush)
   {
-    size_t cmd_size= send_length + key_length + value_length;
+    size_t cmd_size= send_length + ptr->prefix_key_length + key_length + value_length;
     if (cmd_size > MAX_UDP_DATAGRAM_LENGTH - UDP_DATAGRAM_HEADER_LENGTH)
       return MEMCACHED_WRITE_FAILURE;
     if (cmd_size + server->write_buffer_offset > MAX_UDP_DATAGRAM_LENGTH)
       memcached_io_write(server,NULL,0, 1);
   }
-  
+
   /* write the header */
   if ((memcached_do(server, (const char*)request.bytes, send_length, 0) != MEMCACHED_SUCCESS) ||
+      (memcached_io_write(server, ptr->prefix_key, ptr->prefix_key_length, 0) == -1) ||
       (memcached_io_write(server, key, key_length, 0) == -1) ||
-      (memcached_io_write(server, value, value_length, (char) flush) == -1)) 
+      (memcached_io_write(server, value, value_length, (char) flush) == -1))
   {
     memcached_io_reset(server);
     return MEMCACHED_WRITE_FAILURE;
   }
 
-  unlikely (verb == SET_OP && ptr->number_of_replicas > 0) 
-  {
-    request.message.header.request.opcode= PROTOCOL_BINARY_CMD_SETQ;
-
-    for (uint32_t x= 0; x < ptr->number_of_replicas; x++)
-    {
-      ++server_key;
-      if (server_key == ptr->number_of_hosts)
-        server_key= 0;
-
-      memcached_server_st *srv= &ptr->hosts[server_key];
-      if ((memcached_do(srv, (const char*)request.bytes, 
-                        send_length, 0) != MEMCACHED_SUCCESS) ||
-          (memcached_io_write(srv, key, key_length, 0) == -1) ||
-          (memcached_io_write(srv, value, value_length, (char) flush) == -1))
-        memcached_io_reset(srv);
-      else
-        memcached_server_response_decrement(srv);
-    }
-  }
-
   if (flush == 0)
     return MEMCACHED_BUFFERED;
 
   if (noreply)
     return MEMCACHED_SUCCESS;
 
-  return memcached_response(server, NULL, 0, NULL);   
+  return memcached_response(server, NULL, 0, NULL);
 }
 
diff -ur a/libmemcached-0.32/tests/function.c b/libmemcached-0.32/tests/function.c
--- a/libmemcached-0.32/tests/function.c	2011-03-02 20:23:03.000000000 -0800
+++ b/libmemcached-0.32/tests/function.c	2011-03-02 21:47:27.000000000 -0800
@@ -270,7 +270,7 @@
   assert(memcached_set_user_data(memc, foo) == NULL);
   assert(memcached_get_user_data(memc) == foo);
   assert(memcached_set_user_data(memc, NULL) == foo);
-  
+
   return TEST_SUCCESS;
 }
 
@@ -287,10 +287,10 @@
 static test_return  error_test(memcached_st *memc)
 {
   memcached_return rc;
-  uint32_t values[] = { 851992627U, 2337886783U, 3196981036U, 4001849190U, 982370485U, 1263635348U, 4242906218U, 3829656100U, 1891735253U, 
-                        334139633U, 2257084983U, 3088286104U, 13199785U, 2542027183U, 1097051614U, 199566778U, 2748246961U, 2465192557U, 
-                        1664094137U, 2405439045U, 1842224848U, 692413798U, 3479807801U, 919913813U, 4269430871U, 610793021U, 527273862U, 
-                        1437122909U, 2300930706U, 2943759320U, 674306647U, 2400528935U, 54481931U, 4186304426U, 1741088401U, 2979625118U, 
+  uint32_t values[] = { 851992627U, 2337886783U, 3196981036U, 4001849190U, 982370485U, 1263635348U, 4242906218U, 3829656100U, 1891735253U,
+                        334139633U, 2257084983U, 3088286104U, 13199785U, 2542027183U, 1097051614U, 199566778U, 2748246961U, 2465192557U,
+                        1664094137U, 2405439045U, 1842224848U, 692413798U, 3479807801U, 919913813U, 4269430871U, 610793021U, 527273862U,
+                        1437122909U, 2300930706U, 2943759320U, 674306647U, 2400528935U, 54481931U, 4186304426U, 1741088401U, 2979625118U,
                         4159057246U, 1769812374U, 2302537950U, 1110330676U};
 
   // You have updated the memcache_error messages but not updated docs/tests.
@@ -311,7 +311,7 @@
   const char *key= "foo";
   const char *value= "when we sanitize";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -331,17 +331,17 @@
   rc= memcached_flush(memc, 0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     in_value, strlen(in_value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_append(memc, key, strlen(key), 
+  rc= memcached_append(memc, key, strlen(key),
                        " the", strlen(" the"),
                        (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_append(memc, key, strlen(key), 
+  rc= memcached_append(memc, key, strlen(key),
                        " people", strlen(" people"),
                        (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
@@ -370,16 +370,16 @@
   rc= memcached_flush(memc, 0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_set(memc, 
-                    key, strlen(key), 
+  rc= memcached_set(memc,
+                    key, strlen(key),
                     NULL, 0,
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
 
   for (x= 0; store_list[x] ; x++)
   {
-    rc= memcached_append(memc, 
-                         key, strlen(key), 
+    rc= memcached_append(memc,
+                         key, strlen(key),
                          (char *)&store_list[x], sizeof(unsigned int),
                          (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS);
@@ -421,7 +421,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS);
@@ -467,7 +467,7 @@
 
   memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_SUPPORT_CAS, set);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
@@ -490,7 +490,7 @@
   assert(rc == MEMCACHED_END);
   assert(results == NULL);
 #endif
-  
+
   rc= memcached_cas(memc, key, key_length, value2, value2_length, 0, 0, cas);
   assert(rc == MEMCACHED_SUCCESS);
 
@@ -542,7 +542,7 @@
 
   for (x= 0; x < number_of_keys; x++)
   {
-    rc= memcached_set(memc, keys[x], keys_length[x], 
+    rc= memcached_set(memc, keys[x], keys_length[x],
                       keys[x], keys_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -564,7 +564,7 @@
     assert(&results_obj == results);
     assert(rc == MEMCACHED_SUCCESS);
     assert(!memcached_result_cas(results));
-    
+
     char *result_str = memcached_result_value(results);
     assert(strlen(result_str) == specified_length);
 
@@ -615,7 +615,7 @@
 
   for (x= 0; x < number_of_keys; x++)
   {
-    rc= memcached_set(memc, keys[x], keys_length[x], 
+    rc= memcached_set(memc, keys[x], keys_length[x],
                       keys[x], keys_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -643,7 +643,7 @@
     assert(results);
     assert(&results_obj == results);
     assert(rc == MEMCACHED_SUCCESS);
-    
+
     char *result_str = memcached_result_value(results);
     assert(strlen(result_str) == specified_length);
 
@@ -682,17 +682,17 @@
   rc= memcached_flush(memc, 0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_prepend(memc, key, strlen(key), 
+  rc= memcached_prepend(memc, key, strlen(key),
                        "the ", strlen("the "),
                        (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
 
-  rc= memcached_prepend(memc, key, strlen(key), 
+  rc= memcached_prepend(memc, key, strlen(key),
                        "we ", strlen("we "),
                        (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
@@ -707,7 +707,7 @@
   return 0;
 }
 
-/* 
+/*
   Set the value, then quit to make sure it is flushed.
   Come back in and test that add fails.
 */
@@ -720,12 +720,12 @@
 
   setting_value= memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_NO_BLOCK);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
   memcached_quit(memc);
-  rc= memcached_add(memc, key, strlen(key), 
+  rc= memcached_add(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
 
@@ -766,12 +766,12 @@
   const char *value= "when we sanitize";
   const char *original= "first we insert some data";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     original, strlen(original),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
 
-  rc= memcached_replace(memc, key, strlen(key), 
+  rc= memcached_replace(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS);
@@ -785,7 +785,7 @@
   const char *key= "foo";
   const char *value= "when we sanitize";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -806,8 +806,8 @@
   return 0;
 }
 
-static memcached_return  server_function(memcached_st *ptr __attribute__((unused)), 
-                                         memcached_server_st *server __attribute__((unused)), 
+static memcached_return  server_function(memcached_st *ptr __attribute__((unused)),
+                                         memcached_server_st *server __attribute__((unused)),
                                          void *context __attribute__((unused)))
 {
   /* Do Nothing */
@@ -844,7 +844,7 @@
   assert(rc == MEMCACHED_SUCCESS);
 
   /* All keys are valid in the binary protocol (except for length) */
-  if (memcached_behavior_get(memc_clone, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL) == 0) 
+  if (memcached_behavior_get(memc_clone, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL) == 0)
   {
     string= memcached_get(memc_clone, key, strlen(key),
                           &string_length, &flags, &rc);
@@ -885,7 +885,7 @@
     assert(rc == MEMCACHED_SUCCESS);
 
     char *longkey= malloc(max_keylen + 1);
-    if (longkey != NULL) 
+    if (longkey != NULL)
     {
       memset(longkey, 'a', max_keylen + 1);
       string= memcached_get(memc_clone, longkey, max_keylen,
@@ -921,11 +921,11 @@
 
 #define READ_THROUGH_VALUE "set for me"
 static memcached_return  read_through_trigger(memcached_st *memc __attribute__((unused)),
-                                      char *key __attribute__((unused)), 
-                                      size_t key_length __attribute__((unused)), 
+                                      char *key __attribute__((unused)),
+                                      size_t key_length __attribute__((unused)),
                                       memcached_result_st *result)
 {
-  
+
   return memcached_result_set_value(result, READ_THROUGH_VALUE, strlen(READ_THROUGH_VALUE));
 }
 
@@ -968,8 +968,8 @@
   return 0;
 }
 
-static memcached_return  delete_trigger(memcached_st *ptr __attribute__((unused)),  
-                                        const char *key, 
+static memcached_return  delete_trigger(memcached_st *ptr __attribute__((unused)),
+                                        const char *key,
                                         size_t key_length __attribute__((unused)))
 {
   assert(key);
@@ -1020,7 +1020,7 @@
   size_t string_length;
   uint32_t flags;
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1075,7 +1075,7 @@
   size_t string_length;
   uint32_t flags;
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1108,7 +1108,7 @@
   size_t string_length;
   uint32_t flags;
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1142,7 +1142,7 @@
 
   for (x= 0; x < 10; x++)
   {
-    rc= memcached_set(memc, key, strlen(key), 
+    rc= memcached_set(memc, key, strlen(key),
                       value, value_length,
                       (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1171,7 +1171,7 @@
 
     sprintf(key, "foo%u", x);
 
-    rc= memcached_set(memc, key, strlen(key), 
+    rc= memcached_set(memc, key, strlen(key),
                       value, value_length,
                       (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1199,7 +1199,7 @@
   for (x= 0; x < value_length; x++)
     value[x] = (char) (x % 127);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, value_length,
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1235,7 +1235,7 @@
   for (x= 0; x < value_length; x++)
     value[x] = (char) (x % 127);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, value_length,
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1273,7 +1273,7 @@
   uint32_t flags;
   size_t rlen;
 
-  memcached_return rc= memcached_set(memc, keys[0], lengths[0], 
+  memcached_return rc= memcached_set(memc, keys[0], lengths[0],
                                      keys[0], lengths[0], 0, 0);
   assert(rc == MEMCACHED_SUCCESS);
   rc= memcached_mget(memc, keys, lengths, 2);
@@ -1309,7 +1309,7 @@
   memcached_return rc;
   memcached_stat_st memc_stat;
   rc= memcached_stat_servername(&memc_stat, NULL,
-                                 memc->hosts[0].hostname, 
+                                 memc->hosts[0].hostname,
                                  memc->hosts[0].port);
 
   return 0;
@@ -1322,7 +1322,7 @@
   const char *key= "number";
   const char *value= "0";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1369,7 +1369,7 @@
   const char *key= "number";
   const char *value= "3";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1415,13 +1415,13 @@
   const char *key= "fudge";
   const char *value= "sanford and sun";
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)10, (uint32_t)3);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
   memcached_quit(memc);
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)50, (uint32_t)9);
   assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1461,7 +1461,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1476,8 +1476,8 @@
     assert(&results_obj == results);
     assert(rc == MEMCACHED_SUCCESS);
     assert(memcached_result_key_length(results) == memcached_result_length(results));
-    assert(!memcmp(memcached_result_key_value(results), 
-                   memcached_result_value(results), 
+    assert(!memcmp(memcached_result_key_value(results),
+                   memcached_result_value(results),
                    memcached_result_length(results)));
   }
 
@@ -1521,7 +1521,7 @@
 
   for (x= 0; x < number_of_keys; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1585,7 +1585,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1600,8 +1600,8 @@
     assert(results);
     assert(rc == MEMCACHED_SUCCESS);
     assert(memcached_result_key_length(results) == memcached_result_length(results));
-    assert(!memcmp(memcached_result_key_value(results), 
-                   memcached_result_value(results), 
+    assert(!memcmp(memcached_result_key_value(results),
+                   memcached_result_value(results),
                    memcached_result_length(results)));
     memcached_result_free(results);
     x++;
@@ -1611,8 +1611,8 @@
 }
 
 /* Count the results */
-static memcached_return callback_counter(memcached_st *ptr __attribute__((unused)), 
-                                     memcached_result_st *result __attribute__((unused)), 
+static memcached_return callback_counter(memcached_st *ptr __attribute__((unused)),
+                                     memcached_result_st *result __attribute__((unused)),
                                      void *context)
 {
   unsigned int *counter= (unsigned int *)context;
@@ -1635,7 +1635,7 @@
   rc= memcached_flush(memc, 0);
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1646,7 +1646,7 @@
 
   callbacks[0]= &callback_counter;
   counter= 0;
-  rc= memcached_fetch_execute(memc, callbacks, (void *)&counter, 1); 
+  rc= memcached_fetch_execute(memc, callbacks, (void *)&counter, 1);
 
   assert(counter == 3);
 
@@ -1673,7 +1673,7 @@
   rc= memcached_mget(memc, keys, key_length, 3);
   assert(rc == MEMCACHED_SUCCESS);
 
-  while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                       &return_value_length, &flags, &rc)) != NULL)
   {
     assert(return_value);
@@ -1684,7 +1684,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -1694,7 +1694,7 @@
   assert(rc == MEMCACHED_SUCCESS);
 
   x= 0;
-  while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                                         &return_value_length, &flags, &rc)))
   {
     assert(return_value);
@@ -1781,7 +1781,7 @@
     char buffer[SMALL_STRING_LEN];
 
     snprintf(buffer, SMALL_STRING_LEN, "%u.example.com", 400+x);
-    servers= memcached_server_list_append_with_weight(servers, buffer, 401, 0, 
+    servers= memcached_server_list_append_with_weight(servers, buffer, 401, 0,
                                      &rc);
     assert(rc == MEMCACHED_SUCCESS);
     assert(x == memcached_server_list_count(servers));
@@ -1897,10 +1897,6 @@
 
   value= memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE);
   assert(value > 0);
-
-  value= memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS);
-  memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, value + 1);
-  assert((value + 1) == memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS));
   return 0;
 }
 
@@ -1913,7 +1909,7 @@
   unsigned long long total= 0;
   uint32_t size= 0;
   char key[10];
-  char randomstuff[6 * 1024]; 
+  char randomstuff[6 * 1024];
   memcached_return rc;
 
   memset(randomstuff, 0, 6 * 1024);
@@ -1934,17 +1930,17 @@
     memset(randomstuff, 0, 6 * 1024);
     assert(size < 6 * 1024); /* Being safe here */
 
-    for (j= 0 ; j < size ;j++) 
+    for (j= 0 ; j < size ;j++)
       randomstuff[j] = (signed char) ((rand() % 26) + 97);
 
     total += size;
     sprintf(key, "%d", x);
-    rc = memcached_set(memc, key, strlen(key), 
+    rc = memcached_set(memc, key, strlen(key),
                        randomstuff, strlen(randomstuff), 10, 0);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
     /* If we fail, lets try again */
     if (rc != MEMCACHED_SUCCESS && rc != MEMCACHED_BUFFERED)
-      rc = memcached_set(memc, key, strlen(key), 
+      rc = memcached_set(memc, key, strlen(key),
                          randomstuff, strlen(randomstuff), 10, 0);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
   }
@@ -1986,8 +1982,8 @@
 
     snprintf(buffer, SMALL_STRING_LEN, "%u", x);
     getval= memcached_get(memc, buffer, strlen(buffer),
-                           &val_len, &flags, &rc);		
-    if (rc != MEMCACHED_SUCCESS) 
+                           &val_len, &flags, &rc);
+    if (rc != MEMCACHED_SUCCESS)
     {
       if (rc == MEMCACHED_NOTFOUND)
         errors++;
@@ -2051,7 +2047,7 @@
     size_t return_value_length;
     uint32_t flags;
 
-    while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+    while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                                           &return_value_length, &flags, &rc)))
     {
       assert(return_value);
@@ -2095,7 +2091,7 @@
   rc= memcached_mget(memc, keys, key_length, 3);
   assert(rc == MEMCACHED_NO_SERVERS);
 
-  while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                       &return_value_length, &flags, &rc)) != NULL)
   {
     assert(return_value);
@@ -2106,7 +2102,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_NO_SERVERS);
@@ -2116,7 +2112,7 @@
   assert(rc == MEMCACHED_NO_SERVERS);
 
   x= 0;
-  while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                                         &return_value_length, &flags, &rc)))
   {
     assert(return_value);
@@ -2150,19 +2146,19 @@
 
   memcached_flush(memc, 0);
   value= memcached_get(memc, keys[0], key_length[0],
-                        &value_length, &flags, &rc);		
+                        &value_length, &flags, &rc);
   assert(value == NULL);
   rc= memcached_mget(memc, keys, key_length, 4);
 
   count= 0;
-  while ((value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((value= memcached_fetch(memc, return_key, &return_key_length,
                                         &value_length, &flags, &rc)))
     count++;
   assert(count == 0);
 
   for (x= 0; x < 4; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       insert_data, VALUE_SIZE_BUG5,
                       (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS);
@@ -2171,13 +2167,13 @@
   for (x= 0; x < 10; x++)
   {
     value= memcached_get(memc, keys[0], key_length[0],
-                         &value_length, &flags, &rc);		
+                         &value_length, &flags, &rc);
     assert(value);
     free(value);
 
     rc= memcached_mget(memc, keys, key_length, 4);
     count= 0;
-    while ((value= memcached_fetch(memc, return_key, &return_key_length, 
+    while ((value= memcached_fetch(memc, return_key, &return_key_length,
                                           &value_length, &flags, &rc)))
     {
       count++;
@@ -2208,14 +2204,14 @@
 
   memcached_flush(memc, 0);
   value= memcached_get(memc, keys[0], key_length[0],
-                        &value_length, &flags, &rc);		
+                        &value_length, &flags, &rc);
   assert(value == NULL);
   assert(rc == MEMCACHED_NOTFOUND);
   rc= memcached_mget(memc, keys, key_length, 4);
   assert(rc == MEMCACHED_SUCCESS);
 
   count= 0;
-  while ((value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((value= memcached_fetch(memc, return_key, &return_key_length,
                                         &value_length, &flags, &rc)))
     count++;
   assert(count == 0);
@@ -2223,7 +2219,7 @@
 
   for (x= 0; x < 4; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       insert_data, VALUE_SIZE_BUG5,
                       (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS);
@@ -2232,7 +2228,7 @@
   for (x= 0; x < 2; x++)
   {
     value= memcached_get(memc, keys[0], key_length[0],
-                         &value_length, &flags, &rc);		
+                         &value_length, &flags, &rc);
     assert(value);
     free(value);
 
@@ -2242,7 +2238,7 @@
     /* We test for purge of partial complete fetches */
     for (count= 3; count; count--)
     {
-      value= memcached_fetch(memc, return_key, &return_key_length, 
+      value= memcached_fetch(memc, return_key, &return_key_length,
                              &value_length, &flags, &rc);
       assert(rc == MEMCACHED_SUCCESS);
       assert(!(memcmp(value, insert_data, value_length)));
@@ -2304,14 +2300,14 @@
   memcached_flush(memc, 0);
 
   flags= 245;
-  rc= memcached_set(memc, keys, key_length, 
+  rc= memcached_set(memc, keys, key_length,
                     insert_data, VALUE_SIZE_BUG5,
                     (time_t)0, flags);
   assert(rc == MEMCACHED_SUCCESS);
 
   flags= 0;
   value= memcached_get(memc, keys, key_length,
-                        &value_length, &flags, &rc);		
+                        &value_length, &flags, &rc);
   assert(flags == 245);
   assert(value);
   free(value);
@@ -2319,7 +2315,7 @@
   rc= memcached_mget(memc, &keys, &key_length, 1);
 
   flags= 0;
-  value= memcached_fetch(memc, return_key, &return_key_length, 
+  value= memcached_fetch(memc, return_key, &return_key_length,
                          &value_length, &flags, &rc);
   assert(flags == 245);
   assert(value);
@@ -2351,7 +2347,7 @@
 
   for (x= 0; x < 3; x++)
   {
-    rc= memcached_set(memc, keys[x], key_length[x], 
+    rc= memcached_set(memc, keys[x], key_length[x],
                       keys[x], key_length[x],
                       (time_t)50, (uint32_t)9);
     assert(rc == MEMCACHED_SUCCESS);
@@ -2361,7 +2357,7 @@
   assert(rc == MEMCACHED_SUCCESS);
 
   /* We need to empty the server before continueing test */
-  while ((return_value= memcached_fetch(memc, return_key, &return_key_length, 
+  while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                       &return_value_length, &flags, &rc)) != NULL)
   {
     assert(return_value);
@@ -2401,7 +2397,7 @@
   {
     rc= memcached_set(mclone, key, key_len,value, value_length, 0, 0);
 
-    assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_WRITE_FAILURE || 
+    assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_WRITE_FAILURE ||
            rc == MEMCACHED_BUFFERED || rc == MEMCACHED_TIMEOUT);
 
     if (rc == MEMCACHED_WRITE_FAILURE || rc == MEMCACHED_TIMEOUT)
@@ -2467,7 +2463,7 @@
   uint64_t number_value;
 
   value= memcached_get(memc, "autoincrement", strlen("autoincrement"),
-                        &value_length, &flags, &rc);		
+                        &value_length, &flags, &rc);
   assert(value == NULL);
   assert(rc == MEMCACHED_NOTFOUND);
 
@@ -2476,7 +2472,7 @@
 
   assert(value == NULL);
   /* The binary protocol will set the key if it doesn't exist */
-  if (memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL) == 1) 
+  if (memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL) == 1)
     assert(rc == MEMCACHED_SUCCESS);
   else
     assert(rc == MEMCACHED_NOTFOUND);
@@ -2484,7 +2480,7 @@
   rc= memcached_set(memc, "autoincrement", strlen("autoincrement"), "1", 1, 0, 0);
 
   value= memcached_get(memc, "autoincrement", strlen("autoincrement"),
-                        &value_length, &flags, &rc);		
+                        &value_length, &flags, &rc);
   assert(value);
   assert(rc == MEMCACHED_SUCCESS);
   free(value);
@@ -2561,7 +2557,7 @@
 
   for (current_length= 0; current_length < value_length; current_length++)
   {
-    rc= memcached_set(memc, key, strlen(key), 
+    rc= memcached_set(memc, key, strlen(key),
                       value, current_length,
                       (time_t)0, (uint32_t)0);
     assert(rc == MEMCACHED_SUCCESS || rc == MEMCACHED_BUFFERED);
@@ -2595,7 +2591,7 @@
 
   for (x= 0; x < 2; x++)
   {
-    rc= memcached_set(memc, key, strlen(key), 
+    rc= memcached_set(memc, key, strlen(key),
                       NULL, 0,
                       (time_t)0, (uint32_t)0);
 
@@ -2630,7 +2626,7 @@
   size_t length;
   uint32_t flags;
 
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     NULL, 0,
                     (time_t)0, UINT32_MAX);
 
@@ -2745,7 +2741,7 @@
 
   memc= memcached_create(NULL);
   assert(memc);
-    
+
   rc= memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED, 1);
   assert(rc == MEMCACHED_SUCCESS);
 
@@ -2760,7 +2756,7 @@
 
   server_pool = memcached_servers_parse("10.0.1.1:11211 600,10.0.1.2:11211 300,10.0.1.3:11211 200,10.0.1.4:11211 350,10.0.1.5:11211 1000,10.0.1.6:11211 800,10.0.1.7:11211 950,10.0.1.8:11211 100");
   memcached_server_push(memc, server_pool);
-  
+
   /* verify that the server list was parsed okay. */
   assert(memc->number_of_hosts == 8);
   assert(strcmp(server_pool[0].hostname, "10.0.1.1") == 0);
@@ -2993,7 +2989,7 @@
 
   for (x= 0; x < global_count; x++)
   {
-    global_keys[x]= global_pairs[x].key; 
+    global_keys[x]= global_pairs[x].key;
     global_keys_length[x]=  global_pairs[x].key_length;
   }
 
@@ -3008,7 +3004,7 @@
 
   for (x= 0; x < global_count; x++)
   {
-    global_keys[x]= global_pairs[x].key; 
+    global_keys[x]= global_pairs[x].key;
     global_keys_length[x]=  global_pairs[x].key_length;
   }
 
@@ -3181,7 +3177,7 @@
 
   callbacks[0]= &callback_counter;
   counter= 0;
-  rc= memcached_fetch_execute(memc, callbacks, (void *)&counter, 1); 
+  rc= memcached_fetch_execute(memc, callbacks, (void *)&counter, 1);
 
   return 0;
 }
@@ -3230,7 +3226,7 @@
     char buffer[SMALL_STRING_LEN];
 
     snprintf(buffer, SMALL_STRING_LEN, "%u.example.com", 400+x);
-    servers= memcached_server_list_append_with_weight(servers, buffer, 401, 0, 
+    servers= memcached_server_list_append_with_weight(servers, buffer, 401, 0,
                                      &rc);
     assert(rc == MEMCACHED_SUCCESS);
     assert(x == memcached_server_list_count(servers));
@@ -3264,7 +3260,7 @@
   // will not toggle protocol on an connection.
   memcached_version(memc_clone);
 
-  if (memc_clone->hosts[0].major_version >= 1 && memc_clone->hosts[0].minor_version > 2) 
+  if (memc_clone->hosts[0].major_version >= 1 && memc_clone->hosts[0].minor_version > 2)
   {
     memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NO_BLOCK, 0);
     rc = memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, 1);
@@ -3388,7 +3384,7 @@
   // will not toggle protocol on an connection.
   memcached_version(memc_clone);
 
-  if (memc_clone->hosts[0].major_version >= 1 && memc_clone->hosts[0].minor_version > 2) 
+  if (memc_clone->hosts[0].major_version >= 1 && memc_clone->hosts[0].minor_version > 2)
   {
     rc = memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL, 1);
     assert(rc == MEMCACHED_SUCCESS);
@@ -3399,34 +3395,6 @@
   return rc;
 }
 
-static memcached_return pre_replication(memcached_st *memc)
-{
-  memcached_return rc= MEMCACHED_FAILURE;
-  if (pre_binary(memc) == MEMCACHED_SUCCESS) 
-  {
-    /*
-     * Make sure that we store the item on all servers 
-     * (master + replicas == number of servers) 
-     */
-    rc= memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, 
-                               memc->number_of_hosts - 1);
-    assert(rc == MEMCACHED_SUCCESS);
-    assert(memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS) == memc->number_of_hosts - 1);
-  }
-
-  return rc;
-}
-
-static memcached_return pre_replication_noblock(memcached_st *memc)
-{
-  memcached_return rc= MEMCACHED_FAILURE;
-  if (pre_replication(memc) == MEMCACHED_SUCCESS && 
-      pre_nonblock(memc) == MEMCACHED_SUCCESS)
-    rc= MEMCACHED_SUCCESS;
-
-  return rc;
-}
-
 static void my_free(memcached_st *ptr __attribute__((unused)), void *mem)
 {
   free(mem);
@@ -3526,7 +3494,7 @@
   void *test_ptr= NULL;
   void *cb_ptr= NULL;
   {
-    memcached_malloc_function malloc_cb= 
+    memcached_malloc_function malloc_cb=
       (memcached_malloc_function)my_malloc;
     cb_ptr= *(void **)&malloc_cb;
     memcached_return rc;
@@ -3539,7 +3507,7 @@
   }
 
   {
-    memcached_realloc_function realloc_cb= 
+    memcached_realloc_function realloc_cb=
       (memcached_realloc_function)my_realloc;
     cb_ptr= *(void **)&realloc_cb;
     memcached_return rc;
@@ -3552,7 +3520,7 @@
   }
 
   {
-    memcached_free_function free_cb= 
+    memcached_free_function free_cb=
       (memcached_free_function)my_free;
     cb_ptr= *(void **)&free_cb;
     memcached_return rc;
@@ -3570,19 +3538,19 @@
 static memcached_return set_memory_alloc(memcached_st *memc)
 {
   memcached_return rc;
-  rc= memcached_set_memory_allocators(memc, NULL, my_free, 
+  rc= memcached_set_memory_allocators(memc, NULL, my_free,
                                       my_realloc, my_calloc);
   assert(rc == MEMCACHED_FAILURE);
 
-  rc= memcached_set_memory_allocators(memc, my_malloc, my_free, 
+  rc= memcached_set_memory_allocators(memc, my_malloc, my_free,
                                       my_realloc, my_calloc);
-  
+
   memcached_malloc_function mem_malloc;
   memcached_free_function mem_free;
   memcached_realloc_function mem_realloc;
   memcached_calloc_function mem_calloc;
-  memcached_get_memory_allocators(memc, &mem_malloc, &mem_free, 
-                                  &mem_realloc, &mem_calloc);   
+  memcached_get_memory_allocators(memc, &mem_malloc, &mem_free,
+                                  &mem_realloc, &mem_calloc);
 
   assert(mem_malloc == my_malloc);
   assert(mem_realloc == my_realloc);
@@ -3616,7 +3584,7 @@
 
   memcached_version(memc);
 
-  if ((memc->hosts[0].major_version >= 1 && (memc->hosts[0].minor_version == 2 && memc->hosts[0].micro_version >= 4)) 
+  if ((memc->hosts[0].major_version >= 1 && (memc->hosts[0].minor_version == 2 && memc->hosts[0].micro_version >= 4))
       || memc->hosts[0].minor_version > 2)
   {
     memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_SUPPORT_CAS, set);
@@ -3822,7 +3790,7 @@
   assert(rc == MEMCACHED_SUCCESS);
   assert(memc_stat);
 
-  report= memcached_analyze(memc, memc_stat, &rc);  
+  report= memcached_analyze(memc, memc_stat, &rc);
   assert(rc == MEMCACHED_SUCCESS);
   assert(report);
 
@@ -3833,9 +3801,9 @@
 }
 
 /* Count the objects */
-static memcached_return callback_dump_counter(memcached_st *ptr __attribute__((unused)),  
-                                              const char *key __attribute__((unused)), 
-                                              size_t key_length __attribute__((unused)), 
+static memcached_return callback_dump_counter(memcached_st *ptr __attribute__((unused)),
+                                              const char *key __attribute__((unused)),
+                                              size_t key_length __attribute__((unused)),
                                               void *context)
 {
   uint32_t *counter= (uint32_t *)context;
@@ -3932,214 +3900,6 @@
 }
 #endif
 
-static test_return replication_set_test(memcached_st *memc)
-{
-  memcached_return rc;
-  memcached_st *memc_clone= memcached_clone(NULL, memc);
-  memcached_behavior_set(memc_clone, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, 0);
-
-  rc= memcached_set(memc, "bubba", 5, "0", 1, 0, 0);
-  assert(rc == MEMCACHED_SUCCESS);
-
-  /*
-  ** We are using the quiet commands to store the replicas, so we need
-  ** to ensure that all of them are processed before we can continue.
-  ** In the test we go directly from storing the object to trying to
-  ** receive the object from all of the different servers, so we
-  ** could end up in a race condition (the memcached server hasn't yet
-  ** processed the quiet command from the replication set when it process
-  ** the request from the other client (created by the clone)). As a
-  ** workaround for that we call memcached_quit to send the quit command
-  ** to the server and wait for the response ;-) If you use the test code
-  ** as an example for your own code, please note that you shouldn't need
-  ** to do this ;-)
-  */ 
-  memcached_quit(memc);
-
-  /*
-  ** "bubba" should now be stored on all of our servers. We don't have an
-  ** easy to use API to address each individual server, so I'll just iterate
-  ** through a bunch of "master keys" and I should most likely hit all of the
-  ** servers...
-  */
-  for (int x= 'a'; x <= 'z'; ++x)
-  {
-    char key[2]= { [0]= (char)x };
-    size_t len;
-    uint32_t flags;
-    char *val= memcached_get_by_key(memc_clone, key, 1, "bubba", 5, 
-                                    GET_LEN_ARG_UNSPECIFIED,
-                                    &len, &flags, &rc);
-    assert(rc == MEMCACHED_SUCCESS);
-    assert(val != NULL);
-    free(val);
-  }
-
-  memcached_free(memc_clone);
-
-  return TEST_SUCCESS;
-}
-
-static test_return replication_get_test(memcached_st *memc)
-{
-  memcached_return rc;
-
-  /*
-   * Don't do the following in your code. I am abusing the internal details
-   * within the library, and this is not a supported interface.
-   * This is to verify correct behavior in the library
-   */
-  for (uint32_t host= 0; host < memc->number_of_hosts; ++host) 
-  {
-    memcached_st *memc_clone= memcached_clone(NULL, memc);
-    memc_clone->hosts[host].port= 0;
-
-    for (int x= 'a'; x <= 'z'; ++x)
-    {
-      char key[2]= { [0]= (char)x };
-      size_t len;
-      uint32_t flags;
-      char *val= memcached_get_by_key(memc_clone, key, 1, "bubba", 5, 
-                                      GET_LEN_ARG_UNSPECIFIED,
-                                      &len, &flags, &rc);
-      assert(rc == MEMCACHED_SUCCESS);
-      assert(val != NULL);
-      free(val);
-    }
-
-    memcached_free(memc_clone);
-  }
-
-  return TEST_SUCCESS;
-}
-
-static test_return replication_mget_test(memcached_st *memc)
-{
-  memcached_return rc;
-  memcached_st *memc_clone= memcached_clone(NULL, memc);
-  memcached_behavior_set(memc_clone, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, 0);
-
-  const char *keys[]= { "bubba", "key1", "key2", "key3" };
-  size_t len[]= { 5, 4, 4, 4 };
-
-  for (int x=0; x< 4; ++x)
-  {
-    rc= memcached_set(memc, keys[x], len[x], "0", 1, 0, 0);
-    assert(rc == MEMCACHED_SUCCESS);
-  }
-
-  /*
-  ** We are using the quiet commands to store the replicas, so we need
-  ** to ensure that all of them are processed before we can continue.
-  ** In the test we go directly from storing the object to trying to
-  ** receive the object from all of the different servers, so we
-  ** could end up in a race condition (the memcached server hasn't yet
-  ** processed the quiet command from the replication set when it process
-  ** the request from the other client (created by the clone)). As a
-  ** workaround for that we call memcached_quit to send the quit command
-  ** to the server and wait for the response ;-) If you use the test code
-  ** as an example for your own code, please note that you shouldn't need
-  ** to do this ;-)
-  */ 
-  memcached_quit(memc);
-
-  /*
-   * Don't do the following in your code. I am abusing the internal details
-   * within the library, and this is not a supported interface.
-   * This is to verify correct behavior in the library
-   */
-  memcached_result_st result_obj;
-  for (uint32_t host= 0; host < memc_clone->number_of_hosts; host++) 
-  {
-    memcached_st *new_clone= memcached_clone(NULL, memc);
-    new_clone->hosts[host].port= 0;
-
-    for (int x= 'a'; x <= 'z'; ++x)
-    {
-      const char key[2]= { [0]= (const char)x };
-
-      rc= memcached_mget_by_key(new_clone, key, 1, keys, len,
-                                4, GET_LEN_ARG_UNSPECIFIED);
-      assert(rc == MEMCACHED_SUCCESS);
-
-      memcached_result_st *results= memcached_result_create(new_clone, &result_obj);
-      assert(results);
-
-      int hits= 0;
-      while ((results= memcached_fetch_result(new_clone, &result_obj, &rc)) != NULL)
-      {
-        hits++;
-      }
-      assert(hits == 4);
-      memcached_result_free(&result_obj);
-    }
-
-    memcached_free(new_clone);
-  }
-
-  memcached_free(memc_clone);
-
-  return TEST_SUCCESS;
-}
-
-static test_return replication_delete_test(memcached_st *memc)
-{
-  memcached_return rc;
-  memcached_st *memc_clone= memcached_clone(NULL, memc);
-  /* Delete the items from all of the servers except 1 */
-  uint64_t repl= memcached_behavior_get(memc,
-                                        MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS);
-  memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, --repl);
-
-  const char *keys[]= { "bubba", "key1", "key2", "key3" };
-  size_t len[]= { 5, 4, 4, 4 };
-
-  for (int x=0; x< 4; ++x)
-  {
-    rc= memcached_delete_by_key(memc, keys[0], len[0], keys[x], len[x], 0);
-    assert(rc == MEMCACHED_SUCCESS);
-  }
-
-  /*
-   * Don't do the following in your code. I am abusing the internal details
-   * within the library, and this is not a supported interface.
-   * This is to verify correct behavior in the library
-   */
-  uint32_t hash= memcached_generate_hash(memc, keys[0], len[0]);
-  for (uint32_t x= 0; x < (repl + 1); ++x) 
-  {
-    memc_clone->hosts[hash].port= 0;
-    if (++hash == memc_clone->number_of_hosts)
-      hash= 0;
-  }
-
-  memcached_result_st result_obj;
-  for (uint32_t host= 0; host < memc_clone->number_of_hosts; ++host) 
-  {
-    for (int x= 'a'; x <= 'z'; ++x)
-    {
-      const char key[2]= { [0]= (const char)x };
-
-      rc= memcached_mget_by_key(memc_clone, key, 1, keys, len,
-                                4, GET_LEN_ARG_UNSPECIFIED);
-      assert(rc == MEMCACHED_SUCCESS);
-
-      memcached_result_st *results= memcached_result_create(memc_clone, &result_obj);
-      assert(results);
-
-      int hits= 0;
-      while ((results= memcached_fetch_result(memc_clone, &result_obj, &rc)) != NULL)
-      {
-        ++hits;
-      }
-      assert(hits == 4);
-      memcached_result_free(&result_obj);
-    }
-  }
-  memcached_free(memc_clone);
-
-  return TEST_SUCCESS;
-}
 
 static void increment_request_id(uint16_t *id)
 {
@@ -4245,7 +4005,7 @@
   assert(memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP, 1) == MEMCACHED_SUCCESS);
   assert(memc->flags & MEM_USE_UDP);
   assert(memc->flags & MEM_NOREPLY);;
-  
+
   assert(memc->number_of_hosts == 0);
 
   memcached_behavior_set(memc, MEMCACHED_BEHAVIOR_USE_UDP,0);
@@ -4278,11 +4038,11 @@
     if (rc == MEMCACHED_SUCCESS ||
             memc->hosts[server_key].write_buffer_offset < init_offset)
       increment_request_id(&expected_ids[server_key]);
-    
+
     if (rc == MEMCACHED_SUCCESS)
     {
       assert(memc->hosts[server_key].write_buffer_offset == UDP_DATAGRAM_HEADER_LENGTH);
-    } 
+    }
     else
     {
       assert(memc->hosts[server_key].write_buffer_offset != UDP_DATAGRAM_HEADER_LENGTH);
@@ -4370,7 +4130,7 @@
   memcached_return rc;
   uint16_t *expected_ids= get_udp_request_ids(memc);
   unsigned int x;
-  for (x= 0; x < memc->number_of_hosts;x++) 
+  for (x= 0; x < memc->number_of_hosts;x++)
     increment_request_id(&expected_ids[x]);
 
   rc= memcached_flush(memc,0);
@@ -4383,10 +4143,10 @@
   memcached_return rc;
   const char *key= "incr";
   const char *value= "1";
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
-  
+
   assert(rc == MEMCACHED_SUCCESS);
   uint16_t *expected_ids= get_udp_request_ids(memc);
   unsigned int server_key= memcached_generate_hash(memc, key, strlen(key));
@@ -4402,10 +4162,10 @@
   memcached_return rc;
   const char *key= "decr";
   const char *value= "1";
-  rc= memcached_set(memc, key, strlen(key), 
+  rc= memcached_set(memc, key, strlen(key),
                     value, strlen(value),
                     (time_t)0, (uint32_t)0);
-  
+
   assert(rc == MEMCACHED_SUCCESS);
   uint16_t *expected_ids= get_udp_request_ids(memc);
   unsigned int server_key= memcached_generate_hash(memc, key, strlen(key));
@@ -4521,16 +4281,16 @@
   const char **ptr;
   uint32_t values[]= {  3195025439U, 2556848621U, 3724893440U, 3332385401U,
                         245758794U, 2550894432U, 121710495U, 3053817768U,
-                        1250994555U, 1862072655U, 2631955953U, 2951528551U, 
+                        1250994555U, 1862072655U, 2631955953U, 2951528551U,
                         1451250070U, 2820856945U, 2060845566U, 3646985608U,
                         2138080750U, 217675895U, 2230934345U, 1234361223U,
-                        3968582726U, 2455685270U, 1293568479U, 199067604U, 
+                        3968582726U, 2455685270U, 1293568479U, 199067604U,
                         2042482093U };
 
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_MD5);
     assert(values[x] == hash_val);
@@ -4545,12 +4305,12 @@
   const char **ptr;
   uint32_t values[]= {  10542U, 22009U, 14526U, 19510U, 19432U, 10199U, 20634U,
                         9369U, 11511U, 10362U, 7893U, 31289U, 11313U, 9354U,
-                        7621U, 30628U, 15218U, 25967U, 2695U, 9380U, 
+                        7621U, 30628U, 15218U, 25967U, 2695U, 9380U,
                         17300U, 28156U, 9192U, 20484U, 16925U };
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_CRC);
     assert(values[x] == hash_val);
@@ -4563,17 +4323,17 @@
 {
   uint32_t x;
   const char **ptr;
-  uint32_t values[]= {  473199127U, 4148981457U, 3971873300U, 3257986707U, 
-                        1722477987U, 2991193800U, 4147007314U, 3633179701U, 
+  uint32_t values[]= {  473199127U, 4148981457U, 3971873300U, 3257986707U,
+                        1722477987U, 2991193800U, 4147007314U, 3633179701U,
                         1805162104U, 3503289120U, 3395702895U, 3325073042U,
                         2345265314U, 3340346032U, 2722964135U, 1173398992U,
-                        2815549194U, 2562818319U, 224996066U, 2680194749U, 
+                        2815549194U, 2562818319U, 224996066U, 2680194749U,
                         3035305390U, 246890365U, 2395624193U, 4145193337U,
                         1801941682U };
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_FNV1_64);
     assert(values[x] == hash_val);
@@ -4586,17 +4346,17 @@
 {
   uint32_t x;
   const char **ptr;
-  uint32_t values[]= {  1488911807U, 2500855813U, 1510099634U, 1390325195U, 
-                        3647689787U, 3241528582U, 1669328060U, 2604311949U, 
+  uint32_t values[]= {  1488911807U, 2500855813U, 1510099634U, 1390325195U,
+                        3647689787U, 3241528582U, 1669328060U, 2604311949U,
                         734810122U, 1516407546U, 560948863U, 1767346780U,
                         561034892U, 4156330026U, 3716417003U, 3475297030U,
-                        1518272172U, 227211583U, 3938128828U, 126112909U, 
+                        1518272172U, 227211583U, 3938128828U, 126112909U,
                         3043416448U, 3131561933U, 1328739897U, 2455664041U,
-                        2272238452U }; 
+                        2272238452U };
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_FNV1A_64);
     assert(values[x] == hash_val);
@@ -4609,9 +4369,9 @@
 {
   uint32_t x;
   const char **ptr;
-  uint32_t values[]= {  67176023U, 1190179409U, 2043204404U, 3221866419U, 
+  uint32_t values[]= {  67176023U, 1190179409U, 2043204404U, 3221866419U,
                         2567703427U, 3787535528U, 4147287986U, 3500475733U,
-                        344481048U, 3865235296U, 2181839183U, 119581266U, 
+                        344481048U, 3865235296U, 2181839183U, 119581266U,
                         510234242U, 4248244304U, 1362796839U, 103389328U,
                         1449620010U, 182962511U, 3554262370U, 3206747549U,
                         1551306158U, 4127558461U, 1889140833U, 2774173721U,
@@ -4620,7 +4380,7 @@
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_FNV1_32);
     assert(values[x] == hash_val);
@@ -4643,7 +4403,7 @@
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_FNV1A_32);
     assert(values[x] == hash_val);
@@ -4668,7 +4428,7 @@
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_HSIEH);
     assert(values[x] == hash_val);
@@ -4691,7 +4451,7 @@
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_FNV1_64);
     assert(values[x] == hash_val);
@@ -4715,7 +4475,7 @@
 
   for (ptr= list, x= 0; *ptr; ptr++, x++)
   {
-    uint32_t hash_val; 
+    uint32_t hash_val;
 
     hash_val= memcached_generate_hash_value(*ptr, strlen(*ptr), MEMCACHED_HASH_JENKINS);
     assert(values[x] == hash_val);
@@ -4776,7 +4536,7 @@
   {"get3", 0, get_test3 },
   {"get4", 0, get_test4 },
   {"partial mget", 0, get_test5 },
-  {"get_len", 1, get_len_test }, 
+  {"get_len", 1, get_len_test },
   {"get_len2", 0, get_len_test2 },
   {"get_len3", 0, get_len_test3 },
   {"stats_servername", 0, stats_servername_test },
@@ -4859,8 +4619,8 @@
   {"user_supplied_bug15", 1, user_supplied_bug15 },
   {"user_supplied_bug16", 1, user_supplied_bug16 },
 #ifndef __sun
-  /* 
-  ** It seems to be something weird with the character sets.. 
+  /*
+  ** It seems to be something weird with the character sets..
   ** value_fetch is unable to parse the value line (iscntrl "fails"), so I
   ** guess I need to find out how this is supposed to work.. Perhaps I need
   ** to run the test in a specific locale (I tried zh_CN.UTF-8 without success,
@@ -4874,14 +4634,6 @@
   {0, 0, 0}
 };
 
-test_st replication_tests[]= {
-  {"set", 1, replication_set_test },
-  {"get", 0, replication_get_test },
-  {"mget", 0, replication_mget_test },
-  {"delete", 0, replication_delete_test },
-  {0, 0, 0}
-};
-
 test_st generate_tests[] ={
   {"generate_pairs", 1, generate_pairs },
   {"generate_data", 1, generate_data },
@@ -4988,8 +4740,6 @@
   {"consistent_ketama", pre_behavior_ketama, 0, consistent_tests},
   {"consistent_ketama_weighted", pre_behavior_ketama_weighted, 0, consistent_weighted_tests},
   {"test_hashes", 0, 0, hash_tests},
-  {"replication", pre_replication, 0, replication_tests},
-  {"replication_noblock", pre_replication_noblock, 0, replication_tests},
   {0, 0, 0, 0}
 };
 
